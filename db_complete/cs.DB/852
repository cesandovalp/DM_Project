garbag collect techniqu flash resid map ftls niv dayan univers copenhagen copenhagen denmark nday philipp bonnet univers copenhagen copenhagen denmark phbo abstract storag devic base flash memori replac hard disk drive hdds superior perform creas densiti lower power consumpt unfortu nate flash memori subject challeng idiosyncrasi eras write limit block lifetim constraint handl flash translat layer ftl perform place updat wear level garbag collect scene offer applic virtual physic address space class relev ftls employ flash resid associ map tabl logic physic address smaller ram resid cach frequent map entri paper address problem perform ing garbag collect ftls observ problem first maintain metadata need form garbag collect scheme problemat write time phys ical address imag second size metadata remain small ram cach frequent access entri pro pose complementari techniqu call lazi gecko logarithm gecko address issu lazi gecko work well ram plenti store metadata logarithm gecko work well ram plenti effici store metadata flash techniqu applic wide rang flash devic vari amount embed ram introduct year usag storag devic base nand flash memori emmc embed multimedia card sdds solid state drive increas ponenti rate benefit nand flash includ superior perform relat hdds shock resist gradual increas storag densiti lower power consumpt flash memori subject challeng idiosyn crasi flash organ eras block data written sequenti eras block updat data small preced eras oper expens work block granular eras block increas prone data error function number eras endur ssds softwar layer call flash translat layer ftl manag characterist main job implement place updat avoid eras rewrit entir block small data ftl provid map scheme logic physic address garbag collect mechan reclaim invalid space ftl perform wear level ensur block devic wear rate ftl typic store metadata modul embed flash devic simplest implement map scheme ram resid array map logic physic address problem size tabl larg fit ram typic embed flash devic consum ssds portabl electron cost size flash devic central prioriti manufactur typic strive reduc cost provid ing ram cost byte flash memori scale faster cost byte sram decad numer ram effici map scheme propos captur sur vey flash resid associ scheme particu lar dftl lazyftl acknowledg effici scheme scheme store associ map tabl flash cach frequent access entri ram design scheme describ literatur incomplet miss piec garbag collect challeng identifi tackl paper concern metadata need garbag collect modul select victim block infer victim block valid maintain metadata challeng write time physic address imag identifi size metadata requir garbag collect issu flash devic ram propos complementari scheme address problem call lazi gecko stand lazi dram high perform low power consumpt garbag collector scheme flash resid vers map ram resid bitmap enabl victim select live identif scheme feasi ble ssds moder amount embed ram second scheme call logarithm gecko design flash devic ram emmc log arithm gecko lazi gecko store metadata flash requir moder amount intern maintain access leav sig nific lower ram footprint contribut paper introduc problem maintain metadata need enabl garbag collect flash resid map ftls propos complementari techniqu solv garbag collect metadata problem tech niqu suitabl wide rang flash devic vari amount ram evalu techniqu simul demon strate impact write amplif read amplif work flash devic flash devic store data nand chip organ independ array memori cell cell accommod bit slc mlc tlc array flash block row array flash flash typic store block typic flash devic subject challeng idiosyncrasi eras oper preced updat eras granular block block limit lifetim term eras densiti flash devic increas reliabl lifetim block decreas bit shift occur write read electr side effect mitig risk dition constraint write general appli mlc tlc devic write minim granular flash write place sequenti block flash adjac spare bound oob area store metadata typi calli smaller factor con tain logic address well error correct code log base hybrid ftl scheme log base hybrid scheme block ssd divid type data block log block logic adjac address store order address data block map tabl ram logic block physic block look determin block map modulo offset block remain log block buffer updat log block associ mean updat store updat order map log block store ram space incom updat limit log block select merg data block updat data block log block cost merg increas data block eras rewritten set associ sector translat sast scheme log block set associ logic dress space divid equal size set log block accept updat belong set limit cost merg restrict number data block associ log block sast practic file system immc devic log base hybrid scheme interest bast fast log block block associ fulli associ respec tive flash resid associ scheme flash resid associ scheme map tabl associ mean logic written physic requir larg map tabl typic byte flash ble store maintain flash frequent access map entri cach ram exampl dftl map store map entri adjac logic address map flash updat lazili updat updat map entri will exist ram resid map cach entri label dirti cach lru replac strategi evict entri run space dirti entri evict correspond map flash read updat rewritten lazyftl interest variat dftl separ hot cold data strive provid better consist guarante avoid lose cach address event power failur flash resid associ scheme tend involv lower write amplif log base hybrid scheme reason complet flexibl store avoid expens merg oper inher log base hybrid scheme simpli pick block live migrat block free space eras block lower write amplif impli better perform devic longev reliabl challeng associ scheme reli high tempor local data larger work set workload cach miss evict occur lead increas read amplif write amplif desir alloc ram cach frequent access entri shortcom exist scheme flash resid associ map scheme state art term perform relia biliti exist scheme problem dftl address problem maintain metadata determin valid migrat garbag collect oper lazyftl address problem design lie obsolet assumpt oob area store bit indic valid valid assumpt date design flash file system design assum oob left program initi program indic invalid con straint emerg program sequenti block minim electr side effect design lazyftl violat constraint problem maintain metadata garbag collect address adequ work awar concern file system sast ftl oppos state art associ scheme dftl lazyftl reason associ scheme reach turiti hope paper help fill gap problem definit context flash resid associ ftls garbag collect scheme answer question block reclaim valid victim block will question straight forward answer sram abund map tabl fit ram will question difficult answer ram scarc map tabl flash tabl list term paper refer logic physic map tabl map abund ram assum ram plenti store entir map survey techniqu perform victim select live identif victim select greedi simpl method victim select main tain map block number valid block select victim scan map choos block number live maintain map physic address imag updat address imag decrement counter block imag resid lru techniqu victim select lru select block eras longest time ago rational block number live typic requir maintain queue block block insert queue written victim select pop queue issu lru scheme involv migrat greedi scheme guarante chosen block number live window greedi compromis lru greedi polici window greedi implement block queue lru polici appli greedi polici front block queue allow avoid cpu expens scan greedi algorithm increas chanc find block live relat lru polici note method choos victim base age method essenti integr wear level garbag collect scheme work concen trate garbag collect work separ group base updat frequenc perform garbag collect independ group current scope live identif victim chosen check valid three techniqu map scan scan entir map find live target block scan cpu bottleneck valid bitmap pvb cpu intens ternat live bitmap track ssd valid invalid clus tere base block maintain map physic locat imag write shift correspond bit bitmap note greedi polici victim select pvb track number live block ham weight bit associ block flash revers map altern store flash revers map bound compo nent block map indic logic written physic block updat block written order iden tifi valid read map start oper logic address map tabl check physic address correspond block target valid note three techniqu assum map ram examin problem map store flash scarc ram ram scarc map store flash challeng essenti problem case write arriv physi cal locat imag metadata examin polici subsect context victim select greedi window greedi order track number live block phys ical locat imag decrement appropri ate block counter map entri cach address imag unavail counter decrement map flash read write sever increas read amplif lru lru polici unaffect move map flash reli access leverag live identif map scan scan map deter mine valid target block crippl perform map flash prise thousand flash tabl term term descript micron intel seri number block ssd number block size provis measur minus size logic address space size physic address space pba number physic lba number logic block address assum byte size ratio adjac level logarithm lsm tree maximum number level lsm tree bitmap maintain ram resid bitmap indic live problemat reason updat physi cal address imag pre cach map cach shift appropri ate bit bitmap indic invalid access map find imag write increas read amplif flash revers map polici involv read ing revers map oob target block impract reason revers map access map determin logic block typic address will cach map access time oper great increas read amplif problem summari bookkeepingmainten problem meta data need victim select live identif requir maintain updat format physic address imag map entri imag cach naiv solut access map ing read find physic address lead unaccept read amplif scarc ram problem problem metadata consum substanti amount ram ram consum metadata unavail cach frequent access entri degrad formanc limit abil ssds scale ram expens flash section propos novel garbag collect algorithm lazi gecko logarithm gecko address problem extens address problem system model describ scheme outlin assumpt under system consid ssd architectur captur term tabl assum ssd suffici ram store entir map flash flash resid associ ftl store map flash concret experiment evalua tion assum map scheme dftl scribe techniqu introduc paper principl applic lazyftl flash resid associ scheme dftl store map tabl translat flash translat occupi separ block user data reason translat updat frequent consid bene ficial perform separ updat frequenc flash block pool free block activ translat block activ data block translat data written activ block ther group run space request pool free block pool free block empti garbag collect mechan invok ram base tabl call global map directori gmd store locat translat flash final dftl store frequent access map entri ram base tabl call cach map tabl cmt refer entri cmt dirti synchron correspond map entri flash lazi gecko introduc lazi gecko stand lazi bookkeep garbag collector lazi gecko combin techniqu describ problem definit solv bookkeep mainten problem data structur term data structur lazi gecko ram resid bitmap call valid bitmap pvb bit system bit set invalid updat trivial algorithm overrid design logarithm gecko algorithm invalid input physic address pvb algorithm mark physic invalid lazi gecko maintain flash resid revers map map physic logic written revers map store flash oob compon flash map occupi small percentag flash devic tabl arrang map entri physic flash block store flash translat ram resid global revers map directori track whereabout flash map translat belong revers map store separ flash block call revers block revers map updat flash block user data written correspond revers translat read updat reflect logic address written block written flash revers block free space maintain map tail modest overhead read write garbag collect oper final add bit entri cach map ping tabl call synch flag flag set logic address cach imag physic address set invalid pvb oper crux lazi gecko maintain pvb order allow perform victim select live identif logic oper applic write applic updat arriv follow algo rithm algorithm check current map entri logic address cmt insert cmt synchron flag set fals cach invok algorithm invalid physic address set synchroniza tion flag true physic logic resid mark valid pvb last execut write updat cach entri physic address logic note procedur creat fals posit pvb bitmap mark valid invalid resolv fals posit algorithm handl write input write address cach physic address invalid cach synch flag fals cach physic address write cach dirti true algorithm handl applic write applic read handl applic read map ping address cach simpli execut read cach issu read appropri flash translat insert map entri cmt synchron flag set true omit algorithm list oper space constraint translat read resolv fals posit pvb piggyback logic routin oper place ground time cach miss cach evic tion migrat target translat oper take place invok gorithm iter map entri translat cmt syn chroniz flag mark fals physic logic point written mark invalid pvb correct set correspond bit pvb set synch flag cach entri true point imag logic address unsynchron reason algorithm call result evict synchron evict algorithm lazi updat input map foral entri map addr addr cach synch flag invalid cach synch flag true algorithm detect resolv fals posit note algorithm bottleneck number entri translat typic iter array size take hundr nanosecond cost flash opera tion order ten hundr microsecond garbag collect term victim select lazi gecko compat greedi window greedi pvb scan select block fewest live number live block ham ming weight number bit bitmap live identif work refer pvb block chosen garbag collect fals posit exist pvb resolv key insight physic mark valid pvb invalid dirti map entri logic written cach map tabl reason dirti map entri evict cach map tabl pvb updat pvb evict place logic entri current physic address cach exploit insight algorithm resolv remain fals posit read revers translat revers map correspond victim block iter logic address written block cach map tabl synchron flag set fals physic victim fact invalid complet live identif algorithm garbag collect input victim block origin block map revers map foral entri origin block map address cach synch flag address invalid algorithm block eras reset bit correspond physic pvb updat revers map describ subsect reflect order resolv garbag collect metadata mainten problem lazi gecko maintain valid bitmap pvb ram store revers map flash overhead introduc flash read flash write updat revers map garbag collect oper overhead rela tive modest main problem lazi gecko amount ram need proport number ssd bit need issu ssds ram instanc ssd dimens micron tabl requir megabyt bitmap hard limit ssd ram lazi gecko flash resid associ scheme ssd ram store pvb ram consum pvb unavail store frequent access entri cmt degrad perform problem address logarithm gecko introduc logarithm gecko stand logarithm garbag collector lazi gecko main differ logarithm gecko valid map store flash save ram reduc ram footprint relat lazi gecko flash devic market day logarithm gecko requir modest number maintain flash resid pvb logarithm gecko revers map valid iti bitmap pvb lazi gecko ident lazi gecko term pvb updat lazili resolv fals posit revers map differ logarithm gecko store pvb flash lsm tree overview pvb structur seri sort run exponenti increas size flash sort sort map block bitmap bitmap bit physic block indic valid sort ram base buffer date discuss buffer fill flush flash merg proce dure commenc merg sort run discuss perform live identif block search sort run appli bitwis oper product bitmap describ victim select discuss optimis discuss emphas lazi logarithm gecko iden tical term logic live identif crux pvb flash buffer manag logarithm gecko buffer ram size flash buffer sort map block gecko entri gecko entri consist field bitmap size bit offset correspond physic offset block invalid addit bit call eras flag indic block eras eras flag merg subsect logarithm gecko handl applic read write lazi gecko invalid procedur algorithm overload pvb longer simpl ram base bitmap algorithm invok algorithm physic address longer valid first check entri block imag buffer add entri block key blank gecko entri bit bitmap eras flag set bit bitmap correspond invalid set algorithm invalid input physic address block offset offset block block buffer block bitmap blank bitmap buffer block eras flag fals buffer block bitmap offset buffer full flush buffer algorithm buffer fill content flush flash clear entri written flush trigger process merg flash resid sort run describ note flash compris lsm tree alloc separ flash block refer gecko block resolv fals posit pvb algorithm differ algo rithm version invalid method invok algorithm regular data block eras written entri procedur algorithm invok entri correspond block buffer eras flag set entri insert blank bitmap eras flag set algorithm handl block rewritten input block block block buffer block bitmap blank bitmap buffer block eras flag true algorithm merg subsect buffer fill flush gecko block flash call flush sort size level lsm tree consid ram base buffer level lsm tree logarithm gecko tree multipl level denot nth level typic sort level lsm tree tune paramet determin size ratio sort run adjac level tree sort level flash discuss impact paramet perform sort level merg procedur trigger procedur alloc input buffer output buffer ram store level depend dispos origin run merg invok flush continu recurs base state tree merg sort run entri block rule algorithm assum creat tree eras flag discard entri time block eras bitwis oper merg bitmap algorithm merg entri input eras flag true return bitmap bitmap bitmap eras flag eras flag return algorithm maintain ram base data structur call log arithm gecko map directori lgmd track whereabout flash belong lsm tree entri includ valu key live identif lsm tree perform live identif victim block select search sort run start lowest level search encount entri eras flag set true search level requir exact sort lgmd infer candid store key lgmd store start key finish search perform bitwis oper bitmap invok algorithm resolv remain fals posit bitmap imag current live block victim select recal system pool free block pool empti garbag collect mechan invok discuss mechan perform victim select type block logarithm gecko tran lation block store convent logic physic map revers block store revers map gecko block store lsm tree data block store user data conveni refer translat revers gecko block collect inter nal block note intern block occupi block system purpos victim select logarithm gecko treat data block intern block differ inter nal block valid bitmap store ram maintain lazili lazi gecko data block appli lru polici simpl queue call data block queue dbq block eras rewritten insert queue victim select pop top queue search logarithm gecko lsm tree block key valid map candid block cach ram greedi strategi ultim appli pick block number live inter nal block cach data block candid note cach data block candid cold data pick appli rule candid discard pick victim select pro cess note cach data block select start search data block candi pop dbq block lsm tree optimis compress reduc overhead merg tree compress bitmap key insight lsm tree buffer flush bitmap vast major entri bit set number entri fit buffer vast smaller number block system exploit store full bitmap byte block store offset invalid level tree byte allow store time entri buffer flush reduc number lsm tree multi merg mention merg adjac level continu recurs long result merg lead exist run bigger level note wast term continu merg data lower run time reduc number pro activ determin level recurs merg will encompass perform multi sort merg criteria level particip merg particip merg level particip merg run level particip merg combin size rule simpl downsid input buffer need ram perform multi merg number level tree buffer flash resid queue final dbq occupi substanti amount ram relat ram resid data structur logarithm gecko instanc devic dimens micron tabl dbq take ram luckili easi store queue flash input buffer block append eras run free space flush flash ram base structur call queue directori track flash belong dbq input buffer block written block pop input buffer candid garbag collect input buffer run space dbq read queue cost techniqu neglig read write need block rewritten micron analysi tabl breakdown minimum amount ram need ram base data structur lazi logarithm gecko exampl flash devic formula figur deriv term valu tabl cmt list requir strict minimum amount ram assum leftov ram system alloc cmt tabl lazi ram consumpt devic order megabyt domi nant ram occup pvb data structur gmd rmd store whereabout translat global map tabl vers map tabl common lazi gecko loga rithmic gecko logarithm gecko requir ram lazi gecko store pvb flash logarithm gecko store ram base data structur support flash base lsm tree queue logarithm gecko map directori queue map directori track whereabout flash belong lsm tree data block queue map small number flash track small logarithm gecko cach bitmap block host tran lation lsm tree block bitmap consum ram omit calcul ram consumpt bitmap tabl cumbersom final logarith mic gecko buffer lazi gecko support multi merg buffer data block queue input output buffer buffer lsm tree input buffer interest relat amount ram save higher larger micron devic reason larger devic flash pvb grow proport number struc ture grow slower rate number ssd increas relat save ram logarithm gecko magnitud ram save logarithm gecko answer compar magni tude ram save origin dftl enabl con sider minim amount ram need store pure ram base map map entri ram byte assum byte entri compar dftl lazi gecko byte dftl lazi gecko allow duce ram print factor improv logarithm gecko capabl reduc ing ram footprint top magnitud reduct ram consumpt move lazi gecko logarithm gecko equival magnitud ram reduct dftl enabl place exchang lower ram requir logarithm gecko introduc overhead relat lazi gecko captur tabl start cost applic write involv insert lsm tree buffer cost insert lsm tree log number entri tree number entri fit size ratio adjac level tree case logarithm lsm tree equal number block system rough equal number block bitmap fit flash cost applic write lazi gecko logt k·b note express lower experi contribut lsm tree write amplif greater consid addit overhead introduc scheme garbag collect log arithm gecko lazi gecko involv cost flash read flash write garbag collect oper read rewrit revers map logarithm gecko associ addit cost search lsm tree reconstruct block valid iti bitmap candid data block worst case level tree search search level involv worst case cost number level tree logt k·b tabl ram resid data structur dftl logarithm gecko scheme data structur size byte micron intel rie global map directori lba dftl revers map directori pba lazi gecko valid bitmap total global map directori lba dftl revers map directori pba logarithm gecko gecko map directori queue directori cach bitmap buffer total ratio total logarithm total lazi tabl comparison overhead garbag collect techniqu overhead write overhead oper techniqu flash read flash write flash read flash write lazi gecko logarithm gecko logt k·b logt k·b figur impact write amplif scheme decreas ram evalu ssd simul eagletre simul ssd intel seri featur tabl set experi vari amount ram ssd exper iment lazi gecko logarithm gecko oret implement lazi gecko ram cmt workload consist uniform random distribut write logic address space figur scheme allow simul ssd scale start amount ram suffici store entir map cmt halv time measur write amplif theoret implement lazi gecko increas write amplif decreas ram evic tion cmt eventu level approach theoret worst case write involv evict write amplif essenti doubl lazi gecko perform well theoret optim implemen tation scale amount ram decreas logarithm gecko scale lower level ram lazi gecko note bigger ssd cron scale lower level ram relat lazi gecko tabl dot ted blue contribut lsm tree write revers map write write amplif logarithm gecko low garbag collect evic tion cmt constitut bulk write amplif examin impact logarithm gecko read amplif number intern read place applic write factor contribut read amplif garbag collect read lsm tree lookup map read direct revers map factor experi contri bution lsm tree lookup read amplif rang ram plenti ram scarc point overhead logarithm gecko small fraction overhead pay map read garbag collect read conclus introduc problem maintain metadata need perform victim select live identif garbag collect context flash resid associ scheme lazi gecko introduc solv problem entail modest overhead quir store larg bitmap ram bitmap introduc scalabl issu intro duce logarithm gecko store bitmap flash lsm tree logarithm gecko scale lower quantiti ram relat size ssd introduc modest overhead maintain queri lsm tree refer agraw design tradeoff ssd perform usenix assar nemazi estakhri flash memori mass storag architectur incorpor wear level techniqu dec patent dayan svendsen bjørling bonnet bouganim eagletre explor design space ssd base algorithm proc vldb endow aug desnoy analyt model ssd write perform systor grupp davi swanson bleak futur nand flash memori proceed usenix confer file storag technolog fast berkeley usa usenix associ gupta kim urgaonkar dftl flash translat layer employ demand base select cach level address map asplo jim cook micron technolog inconveni truth nand flash memori flash memori summit kawaguchi nishioka motoda flash memori base file system usenix kim kim noh min cho space effici flash translat layer compactflash system ieee tran consum electron kuszmaul comparison fractal tree log structur merg lsm tree white paper apr lee sim hwang cho file system flash storag usenix confer file storag technolog fast santa clara usenix associ lee choi park fast effici flash translat layer flash memori euc workshop feng lazyftl level flash translat layer optim nand flash memori proceed acm sigmod intern confer manag data sigmod york usa acm feng survey address translat technolog flash memori acm comput surv jan cheng gawlick log structur merg tree lsm tree acta inf june park cheon kang roh cho kim reconfigur ftl flash translat layer architectur nand flash base applic acm tran emb comput syst aug robert syke differ consum enterpris flash architectur flash memori summit santa clara stoica ailamaki improv flash write perform updat frequenc proc vldb endow juli zwaenepoel envi volatil main memori storag system asplo 