combin existenti rule descript logic extend version antoin amarilli paristech institut mine cnrs ltci telecom michael benedikt univers oxford queri answer existenti rule implic existenti quanti fier head decid impos restrict rule bodi frontier guarded queri answer decid descript logic allow disjunct function constraint assert relat function focus type schema relat ariti work investig best world decid existenti rule arbitrari ariti relat allow rich descript logic includ function constraint ariti relat negat combin decid languag second introduc express set existenti rule frontier rule restrict combin power constraint ariti relat alcqib retain decid queri answer provid condit add function constraint higher ariti relat introduct year explos techniqu solv queri answer problem queri conjunct atom set logic constraint determin databas call queri constraint answer problem incomplet databas restrict complet research work descript logic refer box box communiti conjunct queri existenti quantif conjunct atom equival basic sql select will assumpt work refer simplic problem queri answer undecid rang arbitrari order logic constraint motiv search restrict constraint languag decid descript logic communiti power languag develop express constraint vocabulari ariti unari relat refer concept binari role languag build concept role basic boolean oper limit quantif lite cdgl alcqib restrict input role function function constraint crucial faith model real relationship relationship person birthdat relationship event start time descript logic power languag ariti vocabulari parallel databas communiti develop rich constraint languag arbitrari ariti existenti rule tupl generat depend tgds existenti rule constraint form conjunct atom general well inclus depend referenti constraint databas express map relationship data exchang data integr general rule undecid subclass decid decid hold chase procedur guarante termin ensur number condit rule weak acycl joint acycl restrict class sourc target tgds ghk survey studi second class tame constraint admit bound treewidth model class guard tgds frontier guard tgds general greedi bound treewidth set featur descript logic disjunct function restrict express existenti rule enjoy best world allow descript logic constraint existenti rule maintain decid paper studi extent paradigm combin class constraint decid relat schema arbitrari ariti express trivial existenti rule relat schema assert express constraint alcqib ariti subschema subset relat ariti schema negat ariti languag featur func tional constraint ariti subschema lead undecid combin simpl acycl rule sourc target tgds simplest istenti rule export variabl frontier inclus depend surpris undecid occur rule export singl variabl class frontier depend existenti rule languag destruct ariti restrict impos head rule tree shape denot loop class existenti rule combin express constraint ariti schema main tain decid call destruct reduct proceed step handl rule tree shape bodi direct rewrit techniqu constraint ariti encod schema second handl rule tree shape bodi show bodi sound replac tree shape approxim sound proven extend techniqu treeific modal guard logic show model constraint unravel tree shape studi addit function depend fds well general descript logic function constraint arbitrari ariti existen tial rule fds general undecid interact existenti rule control impos conflict condit fds existenti rule maintain decid ariti constraint long conflict condit satisfi standard conflict set fds satisfi initi fact violat prove modifi unravel argument advantag combin constraint reduc ariti schema exist algorithm rich descript logic extend arbitrari ariti signatur express constraint work great deal center integr dls datalog style rule includ work earli languag log carin introduc log link horn rule concept descript logic terminolog languag carin broader framework allow concept role terminolog appear rule entail algorithm carin undecid explor borderlin combin rule dls datalog rule existenti rule consid work allow existenti quantif head assert exist higher ariti fact fresh element approach combin descript logic support higher ariti relat direct languag dlrreg support higher ariti retain style syntax support existenti rule cyclic bodi encod dlrreg well arbitrari higher ariti function depend express function assert hand support featur dlrreg regular express role path consid interact rule dls support transit recurs mechan focus order express constraint decid dls existenti rule preliminari signatur fact queri signatur consist relat name associ ate ariti write relat ariti higher ariti relat ariti atom consist relat tupl variabl fact fact clear context con junction atom relat boolean conjunct queri existenti quantifi conjunct atom paper assum simplic cqs boolean free variabl disallow constant loss general boolean queri enumer assign constant encod fresh unari relat constraint consid constraint formula function free constant free order logic signatur interpret interpret consist domain dom interpret function map relat set tupl dom definit satisfi formula written standard wit interpret map relat tupl substitut atom variabl bind studi queri answer problem fact set constraint decid valid entail case write combin complex fix class constraint complex decid constraint class input assum fix input defin data complex problem allow arbitrari constraint class kind integr constraint enjoy decid existenti rule existenti rule tupl generat depend tgd logic constraint form bodi head conjunct atom equal atom constant disallow breviti rule omit quantif write comma rule singl head head consist atom undecid general rule class rule decid satisfi acycl condit will negat restrict class class sourc target tgds partit bodi rule relat head relat extend permiss acycl condit mention introduct second class decid rule guarante suffic consid bound treewidth interpret constraint rule bodi focus class frontier rule frontier rule set variabl occur bodi head rule frontier class inclus depend impos head bodi singl atom variabl frontier empti will focus class inclus depend frontier size decid decid ptime data complex existenti rule augment function depend fds variant existenti rule impos equal write relat form subset call determin undecid combin existenti rule arbitrari fds instanc undecid fds ariti constraint second kind tame constraint ariti constraint defin general languag studi variabl guard fragment count quantifi smallest class constant free formula variabl atom relat close boolean connect guard univers existenti quantif number quantif formula ariti atom free variabl guard formula integ decid data complex descript logic dls ariti constraint languag exampl dls lite cdgl lightweight context ontolog base data access alcqib express full number restrict featur practic lite andalcqib assert concept inclus concept ariti relat mean hold function assert funct role ariti relat correspond despit express alcqib lite captur impli decid role concept atom defin constructor exampl alcqib invers atom role hold intersect role written hold hold true fals concept intersect concept written hold negat concept hold element hold existenti concept role concept hold element note featur function assert negat express existenti rule combin constraint class class existenti rule call destruct ariti decid class conjunct constraint constraint call destruct negat combin class existenti rule decid destruct observ simplest class rule ensur decid base chase ter minat class sourc target tgds destruct surpris arbitrari constraint ariti signatur add depend sourc target theorem destruct ariti ariti queri satisfi problem fact constraint satisfi move class existenti rule decid guarded assumpt observ class frontier inclus depend destruct ariti fact function assert binari relat suffici undecid lift function assert higher ariti relat standard reduct entail depend undecid entail fds theorem adapt prove theorem destruct ariti undecid lite featur function assert surpris frontier rule destruct ariti export singl variabl hold ariti reason express disobey variabl restrict theorem destruct ariti ariti queri motiv search restrict existenti rule class destruct ariti existenti rule ariti will focus subclass frontier rule head trivial berg cycl definit berg cycl conjunct atom sequenc length pairwis distinct variabl pairwis distinct atom occur atom addit modulo occur loop berg cycl length berg cycl atom defin head loop hnl subclass rule head loop singl head rule head loop exampl rule hnl hnl claim head loop rule destruct contrast general frontier rule theorem theorem hnl destruct ariti cours decid hnl express alcqib rest prove theorem address complex shred proof theorem translat hnl rule ariti constraint common repres general relat databas binari relat store call shred repres ari relat set binari relat link tupl materi element attribut translat signatur shred ariti signatur constraint impos interpret ensur decod interpret second explain shred fact cqs definit shred signatur signatur consist unari relat elt unari relat binari relat well formed constraint written constraint alcqib express elt unari relat elt elt binari elt elt funct shred shr fact fact atom elt variabl replac atom atom fresh variabl shred shr defin exampl consid xyz defin shr xyzt elt elt elt fulli loop interest defin shred hnl rule restrict class fulli loop rule fnl head bodi loop fnl direct shred will move fnl hnl existenti rule defin shred shr existenti rule shr shr fresh element introduc shred claim lemma fnl rule shr translat ptime sentenc exampl breviti exampl ignor elt atom shred con sider fnl rule shred express alcqib contrast consid rule hnl shred express yzt general case rewrit lemma ptime bodi head shr tree fulli loop easi general result proposit shred fact constraint existenti rule equival shr shr shr lemma shr shr shr comput ptime definit deduc case fnl corollari fnl constraint reduc ptime constraint queri fix input output data complex bound preserv conclud proof theorem fnl constraint impli fnl complet data complex combin complex note decid realist implement translat reduc ariti constraint dls alcqib impos impos addit minor restrict fnl rule atom form simplic focus sequel reduct decid ariti translat investig restrict ensur output translat express dls head loop extend claim hnl fnl idea rewrit hnl rule fnl treeifi consid fulli loop rule impli way match part interpret satisfi fact formal assum fact atom variabl fresh unari relat defin definit treeific fact hnl rule frontier variabl conjunct trf fnl rule defin consid map renam variabl consid map variabl construct replac occurr fresh variabl fact replac copi fulli loop add trf exampl consid fact rule treeific trf rule consid rule fact variabl trf claim proposit fact constraint hnl rule equival trf proposit impli hnl reduc fnl decid shred proposit prove theorem prove proposit direct fresh unari relat interpret assum interpret tupl impli trf interpret direct assum trf shred proposit impli interpret shr trf shr existenti closur shr appli unravel argument cycl free definit gaifman graph interpret undirect graph dom connect element occur tupl fact interpret cycl free wit cycl element dom lemma unravel fact constraint satisfi interpret cycl free let unravel interpret unravel lemma unshr interpret definit unshred interpret set creat tupl proof shred proposit unshred well defin satisfi unshred constraint trf satisfi trf match hnl rule match trf match wit cycl free lemma sound fact hnl rule interpret satisfi shr trf cycl free shr unshred satisfi conclud sketch proof unravel lemma interpret dom occur tupl call bag interpret domain consist tupl mention build graph bag connect bag domain share element pick wit merg fact bag bag domain includ dom unravel tree bag unfold start fact bag preserv bag fact bag domain element occur exact sibl parent occur exact children introduc interpret form union bag construct induct bag correspond bag construct children bag adjac share element correspond element introduc creat isomorph copi child domain fresh element perform unravel process recurs children unravel oper preserv constraint fact negat tree interpret describ cycl free wit copi fact bag complex proposit reduct hnl fnl output exponenti size input treeific let bound size output reduct input size let bound combin complex upper bound hnl treeific rewrit rule fact depend previous case fnl data complex bound impli data complex bound hnl function depend previous languag head loop frontier rule destruct kind rule support higher ariti relat function depend fds well undecid arbitrari fds constraint trivial destruct turn undecid hold hnl rule fds fact singl head rule fds theorem undecid fds singl head frontier rule fds determin size kind existenti rule fds decid case conflict rule fds definit singl head existenti rule conflict respect set fds let head atom let subset frontier variabl iff strict subset determin exact determin existenti quantifi variabl occur note requir rule singl head head loop result respect fds theorem conflict frontier rule fds destruct ariti singl head frontier rule fds destruct ariti variabl head atom rule assum occurr simpl suffici condit impli conflict condit prove theorem assum loss general fds higher ariti relat write shred fds translat function assert path express express dls sroiq conflict requir fds hold interpret long hold wit fact proposit constraint conflict frontier rule fds fact interpret satisfi wit satisfi satisfi prove proposit consid treeific trf conflict treeific rule bodi shred proposit interpret shr shr trf existenti closur shr hypothesi exist wit assum wit unshred satisfi previous unravel lemma assum cycl free modifi lemma addit ensur properti will forbid violat unshred definit set fds interpret wit fact call safe dom determin consid dom rji dom safeti reason lemma set fds interpret cycl free safe wit unshred satisfi unshred satisfi claim variant unravel lemma lemma awar unravel constraint fact conflict frontier rule set fds interpret satisfi shr shr trf shr andw wit shr interpret satisfi wit shr cycl free safe prove lemma tweak unravel process ensur safeti creat children bag unravel neighbor correspond bag bag graph omit neighbor shred higher ariti tupl share element occur strict superset determin unravel differ neighbor occur exact determin unravel satisfi existenti closur satisfi shr trf conflict condit ensur fact requir rule appli awar unravel lemma consid unshred result satisfi constraint includ lemma prove proposit conclud prove theorem observ extend general notion fact allow inequ axiom inequ fact preserv shred unshred unravel theorem hold fact inequ complex second enumer equal variabl fact possibl consid fact variabl merg equal inequ assert remain variabl proposit impli origin entail hold iff deriv entail hold replac canon interpret satisfi test ptime reduc fnl term complex exptim hard combin complex satisfi usual variabl guard fragment exptim hard gra addit exponenti factor impact bound appli conflict frontier rule fds conclus paper studi impact existenti rule decid queri answer class ariti constraint explain prove theorem decid extend inequ allow fact limit arbitrari ariti constraint rule depend futur work will studi extend arbitrari ariti constraint languag featur disjunct will studi presenc constant nomin disallow rule languag consid break decid ariti context requir techniqu unravel creat multipl copi constant question requir specif tool studi finit restrict finit interpret acknowledg grate bori motik pierr senellart help feedback work part support paristech chair big data market insight engin physic scienc council grant refer serg abiteboul richard hull victor vianu foundat databas addison wesley franz baader descript logic handbook theori implement plicat cambridg univers press jean franc baget fabien garreau mari laur mugnier swan rocher extend acycl notion existenti rule ecai vinc georg gottlob martin otto queri guard fragment lmcs jean franc baget michel lecl mari laur mugnier walk decid rule existenti variabl jean franc baget michel lecl mari laur mugnier eric salvat tend decid case rule existenti variabl ijcai jean franc baget michel lecl mari laur mugnier eric salvat rule existenti variabl walk decid artif intel jean franc baget mari laur mugnier sebastian rudolph micha thomazo walk complex line general guard existenti rule ijcai catriel beeri mosh vardi implic problem data depend icalp cdgl diego calvanes giusepp giacomo domenico lembo maurizio lenzerini riccardo rosati lite tractabl descript logic ontolog aaai diego calvanes thoma eiter magdalena ortiz regular path queri express descript logic nomin ijcai diego calvanes giusepp giacomo maurizio lenzerini conjunct queri contain answer descript logic constraint tocl andrea cal georg gottlob thoma lukasiewicz general datalog base framework tractabl queri answer ontolog web semant andrea cal georg gottlob andrea pieri express ontol ogi languag queri answer problem artif intel andrea cal domenico lembo riccardo rosati decid complex queri answer inconsist incomplet databas pod andrea cal domenico lembo riccardo rosati queri rewrit swere constraint data integr system ijcai francesco donini maurizio lenzerini daniel nardi andrea schaerf hybrid system datalog concept languag ronald fagin degre acycl hypergraph relat databas scheme jacm ronald fagin phokion kolaiti rene miller lucian popa data exchang semant queri answer tcs ghk bernardo cuenca grau ian horrock markus kro tzsch clemen kupk spoina magka bori motik zhe wang acycl notion existenti rule applic queri answer ontolog jair erich gra del colin hirsch martin otto guard modal logic tocl birt glimm carsten lutz ian horrock ulrik sattler conjunct queri answer descript logic shiq jair gra erich gra del restrain power guard symbol logic ian horrock oliv kutz ulrik sattler irresist sroiq yevgeni kazakov polynomi translat variabl guard frag ment number restrict guard fragment jelia markus kro tzsch sebastian rudolph extend decid existenti rule join acycl guarded ijcai maurizio lenzerini data integr theoret perspect pod alon levi mari christin rousset combin horn rule descript logic carin artif intel john mitchel implic problem function inclus dependen cie control ian pratt hartmann data complex variabl fragment count quantifi inf comput sebastian rudolph birt glimm nomin invers count conjunc tive queri infin friend jair stephan tobi complex practic algorithm logic knowl edg represent phd thesi proof negat combin proof theorem destruct adapt proof theorem rewrit replac atom hand side atom rule clear sourc target impos concept inclus clear rule equival theorem proof appli proof theorem destruct rest appendix write posit relat will undecid result consid entail problem definit unrestrict entail problem class constraint ask set constraint constraint entail written interpret interpret reduct class logic constraint entail class con straint rule idea theorem complic care difficulti lemma class constraint existenti rule reduct entail proof consid instanc entail problem set constraint existenti rule reduc instanc problem creat fresh unari relat consid instanc fact queri claim iff prove reduct correct consid interpret satisfi existenti closur appli wit deduc exist match prove convers exist interpret satisfi mean violat set element dom match extend match modifi set element correspond set relat clear satisfi mention fresh unari relat construct satisfi existenti closur satisfi match element occur imposs extend match match definit violat wit reduct correct conclud proof express assert funct binari relat undecid suffic undecid entail definit call ufd class unari function depend ufd function depend arbitrari ariti relat determin consist singl attribut write ufd posit higher ariti relat claim function assert binari relat bootstrap ufd arbitrari ariti relat lemma reduct entail ufd entail proof consid constraint ufd rule encod ufd rule fresh binari relat function assert funct constraint consist origin rule rule function assert claim iff counterexampl interpret satisfi claim satisfi thing check ufd satisfi assum ufd violat tupl satisfi rule contradict assert funct suppos respect satisfi satisfi wit convers counterexampl interpret satisfi loss general fresh relat mention extend interpret satisfi tupl clear result satisfi rule satisfi rule easili satisfi function assert violat assert wit violat ufd mention satisfi wit reduct correct conclud proof definit class frontier inclus depend unari inclus depen denci class inclus depend frontier size write rule posit frontier variabl occur bodi head atom convent write rule rarb scsd denot rule frontier variabl occur posit bodi head second occur posit bodi head rememb definit requir variabl occur bodi atom head atom note explain add loss general frontier inclus dependen cie unari inclus depend entail problem reason rule encod addit attribut lemma reduct entail ufd entail ment ufd proof consid constraint ufd signatur relat creat relat posit posit rule form posit rule form encod rule rule defin constraint consist addit rule straightforward rewrit origin ufd constraint rewrit rarb scsd iff extend counterexampl interpret interpret satisfi consid tupl creat tupl defin posit form form clear result satisfi ufd constraint violat mention attribut clear satisfi rule origin interpret satisfi rule wit convers rewrit counterexampl interpret interpret simpli remov addit attribut tupl clear inter pretat satisfi satisfi rule satisfi rule constraint preserv conclud proof readi conclud theorem entail problem ufd und cidabl stronger result claim definit forbid repetit posit allow rule formrprq rrrr refer appendix detail stronger result prove conclud proof theorem decid decid entail problem reduc success lemma lemma lemma proof theorem destruct formal defin satisfi problem fact constraint check interpret existenti closur will satisfi problem undecid weaker alcf alcf express addit constructor allow disjunct concept tile system notat tile system empti finit set tile binari relat intuit stand horizont vertic sequenc infinit tile problem determin exist infinit tile function choos fix infinit tile problem input undecid consid singl rule xyz impos function restrict funct funct intuit stand creat concept tile impos disjoint assert impos concept inclus impos concept inclus cjl cjl tile cjk readi conclud reduct claim infinit tile problem input reduc satisfi fact constraint impos defin cci prove constraint satisfi iff infinit problem input solut assum infinit tile problem solut consid interpr tation dom defin cik interpret satisfi rule disjoint assert concept inclus fact tile existenti closur fact constraint satisfi convers interpret satisfi constraint existenti closur fact satisfi existenti closur satisfi function assert build infinit grid edg top left corner match variabl vertic element grid constraint impos carri exact tile defin function map hold constraint ensur valid tile infinit tile problem solut conclud proof reduct correct undecid tile problem deduc undecid satisfi fact rule constraint alcf impli claim theorem proof existenti rule ariti proof lemma shred fnl definit recal definit call interpret cycl free gaifman graph acycl call frontier existenti rule cycl free conjunct atom head bodi cycl free call cycl free gaifman graph acycl defin gaifman graph variabl vertic edg pair variabl occur atom lemma cycl free frontier existenti rule translat ptime equival sentenc claim clear impli lemma cycl free free variabl translat quadrat time equival formula free variabl lemma proven lemma write existenti rule xfx formula lemma proof test ptime connect rewrit ptime cqs conjunct atom connect translat ptime translat assum loss general connect proceed induct number atom result trivial set atom free variabl occur set variabl occur set variabl exist path vertex set atom variabl set comput linear time answer reachabl question number set linear comput take quadrat time claim partit variabl connect variabl adjac path variabl path justifi set cover variabl set pairwis disjoint construct second variabl consid edg path cycl contradict third disjoint let connect path cycl contradict reason partit atom observ conjunct atom free variabl acycl connect disjoint appli induct hypothesi justifi written quadrat time partit atom occur atom variabl occur variabl express complex rewrit quadrat induct hypothesi appli set atom partit atom origin input formula quadrat time spent rewrit set atom quadrat input formula induct proof complet conclud proof lemma observ fnl rule shr cycl free frontier existenti rule head bodi lemma lemma loop conjunct atom shr cycl free proof cycl shr clear translat berg cycl length higher ariti atom case contradict fact loop proof proposit shred start defin shred interpret definit interpret shred shr interpret elt dom tupl creat fresh element dom add ajr add interpret shred satisfi unshred sens definit lemma negat cqs fact existenti rule preserv shred lemma fact set existenti rule interpret satisfi existenti closur iff shr satisfi shr shr existenti closur shr defin notion homomorph definit interpret map dom dom homomorph relat tupl tupl notion extend homomorph queri interpret usual manner lemma interpret homomorph extend homomorph shr shr convers homomorph shr shr restrict homomorph proof pay attent fact homomorph defin map tupl tupl describ extend homomorph shr shr defin imag dom shr dom convers homomorph shr shr restrict dom easili homomorph prove lemma proof prove claim queri lemma homomorph shr shr iff homomorph fact case queri rule consid existenti rule assum consid homomorph bodi shr shred bodi shr imag violat shr lemma restrict homomorph bodi extend homomorph bodi head lemma extend homomorph shred head bodi shr match bodi shr conclud wit violat shr convers assum shr shr consid homomorph bodi extend homomorph bodi shr shr extend homomorph bodi head shr shr lemma justifi defin homomorph bodi head match bodi conclud wit violat prove lemma preserv constraint lemma interpret theori iff shr proof restrict shr shr ident rememb fresh occur shr satisfi constraint prove direct result counterexampl interpret shred interpret shr shr shr lemma satisfi lemma initi observ shred interpret remain prove convers direct decod interpret shr shr shr harder argu understood shred interpret appli requir deal issu redund tupl definit interpret redund free dom tupl belong redund tupl obstacl prevent understand inter pretat shred interpret lemma shr biject interpret redund free interpret satisfi proof clear write shr unshred oper definit observ interpret shr shr redund free interpret satisfi shr shr conclud proof redund freeness express counterexampl interpret satisfi matter recal definit lemma interpret redund free interpret proof interpret defin equival relat dom ajr iff rji condit ensur equival relat pairwis disjoint defin dom dom function map element dom equival class imag redund free dom wit redund preimag element equival fact element ajr adjac easili check interpret homomorph satisfi existenti closur satisfi restrict coincid interpret satisfi shr suffic exist homomorph build homomorph set dom preimag homomorph consid tupl preimag tupl clear fresh binari relat element singleton class write pair eltj impli ajr pairwis disjoint rji iff rji homomorph satisfi shr existenti rule satisfi shr suffic observ ident match bodi shr match shr extend match bodi head map match bodi head shr wit violat shr satisfi shr complet proof proposit backward direct interpret redund free lemma unshr interpret lemma shr conclud lemma lemma satisfi existenti closur proof lemma unravel formal unravel process work signatur definit interpret induc interpret dom interpret tupl element occur guard pair pair distinct element dom occur tupl neighborhood inj dom dom guard pair bag interpret interpret induc guard pair bag graph interpret undirect graph bag loop distinct bag adjac domain share common element domain size share exact element wit fact alter definit bag graph fact bag correspond wit fact bag adjac bag share element share element definit tree interpret tree bag interpret root bag direct edg relat requir domain share exact element exact occur place introduc children includ bag share element sibl child write dom dom interpret fact wit unravel preserv fact bag bag domain size element dom occur introduc goal will construct unravel counterexampl interpret lemma unravel interpret preserv wit fact interpret wit cycl free recal definit proof dom tree match element dom dom occur tupl edg correspond edg bag introduc bag introduc unravel faith constraint preserv definit faith unravel interpret preserv wit fact unravel preserv exist homomorph map bag map fact bag map bag fact bag requir compat compat dom isomorph ident dom int isomorph inj surj surject bag domain subset dom preimag interpret unravel element interpret occur tupl binari relat bag graph connect assum loss general interpret unravel tupl fresh binari relat satisfi condit claim proposit fact constraint unravel interpret satisfi wit faith unravel preserv interpret satisfi existenti closur fact wit proof clear wit satisfi exist homomorph satisfi satisfi expand origin interpret interpret relat name rewrit constraint conjunct formula guard fragment variabl number restrict number restrict form binari relat fact number restrict preserv depend neighborhood element isomorph preserv properti preserv show exist guard bisimul defin guard bisimul set restrict singleton guard pair partial isomorph condit satisfi consid guard set partial isomorph domain agre restrict consid guard set unravel singleton occur guard pair suffic consid case correspond bag distinguish depend intersect dom dom find isomorph domain ident dom surject properti surj exist compat properti compat imag dom correspond partial isomorph trivial case element properti int isomorph inj exist guard pair partial isomorph agre restrict conclud proof faith unravel exist proposit fact unravel interpret wit faith unravel preserv proof build defin root set initi ident defin induct homomorph map bag consid correspond bag element introduc consid bag bag graph share element adjac bag graph let dom creat bag child domain fresh set isomorph copi map perform process induct child bag clear result process unravel clear defin homomorph creat tupl clear homomorph imag clear map fact bag properti compat clear restrict bag isomorph properti element dom clear int isomorph inj int consist union bag introduc children share children correspond exact bag occur properti surj surject unravel bag reachabl fact bag conclud proof interpret unravel loss general unravel proposit proposit lemma ensur result satisfi requir condit proof lemma treeific sound call bad cycl conjunct atom berg cycl length higher ariti atom definit fact hnl rule interpret assum cycl free shr wit exist guarante lemma easili impli loop domain unshred assum satisfi shr trf assum map bodi wit violat consid depend impli identifi variabl bodi map element match map variabl bodi distinct element fnl rule trf violat violat trf contradict fact unshred satisfi shr trf proposit assum fnl rule bodi bad cycl map variabl bodi distinct element imag bad cycl bodi bad cycl loop bad cycl map element dom consid set variabl map element dom set map variabl variabl precis wit shr defin includ atom perform construct definit result fnl bad cycl translat bad cycl element match dom contradict fact loop dom trf match map frontier variabl element trf contradict fact wit violat conclud proof proof function depend proof theorem undecid fds singl head rule call class singl head frontier rule recal definit entail problem definit ufd definit will write rule definit lemma entail problem ufd reduc ufd suffic undecid undecid will adapt result implic rule ufd constraint undecid will consid special form problem studi definit restrict ufd entail problem entail problem ufd input restrict relat rule rarb rcrd input ufd hold input state variant undecid result theorem restrict ufd entail problem undecid proof recal proof techniqu proof reduct entail problem undecid problem system equat form function monoid decid equat entail system problem reduc entail problem system creat relat attribut variabl extra attribut impos ufd rule posit ensur project rarx interpret graph function equat form understood correspond assert function repres rarx rari rarz lemma assert enforc constraint ryrx rarz constraint constraint observ enforc constraint equat variabl replac occurr equat fresh variabl add equat clear problem equival origin encod constraint actual rule lemma observ equat form equival assert arxi rarxi rarxi rarxi project observ implic problem restrict fact assum form restrict ufd problem featur rule rule encod equat form ryrx rarz ufd constraint hold clear violat interpret satisfi impli exist violat problem equival add ufd equat equat form rxi rxi hold condit restrict ufd problem satisfi step reduc restrict ufd set elimin rule variant lemma encod rule rule fresh posit ufd condit restrict ufd problem respect easili affect rest proof project addit attribut popul determin violat addit ufd remain proposit reduct restrict ufd entail problem entail ufd proof consid instanc restrict ufd bid entail problem relat set ufd set rule rule number posit construct relat posit posit translat ufd ufd let ufd translat rule rarb rcrd rule describ rule translat consid rule rarb rcrd creat rule defin zij creat second rule defin zij instanc rule encod note condit restrict ufd bid entail problem ufd hold head rule match element likewis second rule result encod claim iff constraint rarb rcrd assumpt restrict ufd bid entail problem consid translat consid defin let intuit translat entail hold rewrit impli straightforward rewrit consid interpret consid tupl wit violat exist ple satisfi exist tupl satisfi put wit violat prove proceed proof fact iff reduct correct assum interpret violat project posit formal satisfi clear satisfi previous observ clear satisfi satisfi clear violat violat wit convers assum counterexampl interpret creat construct product creat tupl tupl clear satisfi satisfi fds posit posit reason violat check satisfi rarb rcrd rule satisfi tupl construct wit violat tupl construct satisfi tupl construct wit violat satisfi wit reduct sound conclud proof conclud proof theorem combin lemma proposit theorem proof lemma safeti cycl freeness set fds interpret assum cycl free safe witnessw fact note slight abus terminolog relat definit cycl free wit satisfi condit definit cycl free unshred consid tupl violat rememb impli assumpt unshred satisfi posit determin posit determin consid set singleton set imag shred creat cycl shr consist element contradict fact cycl free singleton set common element consid shred shr shr determin shr safe forw dom contradict fact safe proof lemma unravel fds assum loss general hnl constraint unari higher ariti relat head hnl rule violat condit replac head fresh unari atom frontier variabl assert constraint impli head atom defin definit proper guard pair interpret pair distinct element dom occur relat note satisfi guard pair pair occur tupl relat pair occur tupl relat proper bag bag induc proper guard pair interpret elt ariti neighborhood restrict inj proper guard pair unravel will creat definit faith unravel interpret preserv wit fds unravel preserv recal definit exist homomorph dom dom map bag map fact bag map bag fact bag requir compat compat proper bag dom isomorph ident dom isomorph surj surject proper bag proper bag domain subset preimag interpret safe achiev dom relat subset posit strict superset determin rji true interpret exact determin let isomorph intuit properti achiev design preserv exact assert conflict rule case frontier variabl exact determin includ pattern equal frontier variabl atom preserv remain safe modifi definit unravel interpret requir element interpret occur tupl binari relat bag graph connect proper bag remov ensur loss general fresh binari relat ensur condit correct unravel proposit fact constraint fds conflict constraint unravel interpret satisfi shr wit faith unravel preserv interpret safe satisfi shr wit proof clear safe properti satisfi homomorph satisfi argument proof propo sition note refer fresh relat suffici isomorph ariti neighborhood surject proper bag harder shr satisfi consid consid match bodi shr element dom frontier variabl map consid imag homomorph satisfi shr impli element dom head shr match homomorph map frontier variabl singl head depend assumpt head unari higher ariti head unari head shr consid restrict proper bag bag exist assum interpret unravel restrict isomorph conclud unari head atom head shr match match wit violat shr assum head higher ariti higher ariti relat subset posit set posit head frontier variabl occur dom rji conflict condit strict superset determin exact determin properti achiev ensur rti dom conflict condit variabl head posit existenti variabl occurr fact satisfi ensur head shr match map frontier variabl wit violat shr determin properti achiev ensur rti dom int inj isomorph impli head shr suitabl match wit violat shr tupl rti ground atom head atom homomorph map frontier variabl element posit equal frontier variabl posit variabl posit homomorph map frontier variabl satisfi justifi satisfi requir constraint conclud proof describ faith unravel process proposit fact set fds unravel inter pretat wit unshred satisfi faith unravel preserv proof modifi proof proposit way modif unravel bag element introduc eltj deal differ proper bag adjac bag graph detail set proper bag bag graph share add proper consid subset posit higher ariti relat rji strict superset determin occur realis wit occur add children proper bag proper bag determin bag realiz creat child tupl wit occur unravel child determin case rti pick bag realiz creat child tupl wit occur unravel child inform proper bag set posit higher ariti relat occur keep strict superset determin determin trigger happili unravel bag occur posit determin unravel occur posit choos repres bag case current bag proper includ bag examin infinit chain copi bag problem infinit case unravel proper bag copi tupl wit occur relev posit occur posit copi tupl will complet posit unravel step second modif unravel bag element introduc element eltj satisfi compar tupl modif case tupl copi posit rbi rji addit neighbor bag graph ordinarili consid consid virtual neighbor bag tupl interpret unravel usual inform unravel proper bag repres higher ariti ground atom element atom introduc parent bag occur multipl posit subset posit miss occurr bag will copi bag parent exampl assum unravel element shred tupl determin fds unravel will creat shred ground atom tupl note posit occur fresh copi creat unravel virtual neighbor tupl tupl tupl tupl note tupl wit second violat safeti tupl correct properti compat hold reason origin construct surj hold gaifman graph connect fresh binari relat consid proper bag safeti properti hold initi copi wit shred higher ariti tupl occur unshred satisfi properti preserv unravel observ creat atom form relat set posit fresh determin determin occur posit check properti achiev satisfi dom consid bag introduc check condit condit clear construct child wit occur posit second condit hold determin creat child bag realiz unravel child conclud lemma origin interpret unravel loss general appli proposit conclud proposit lemma 