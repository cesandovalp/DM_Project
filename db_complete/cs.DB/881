elimin recurs monad datalog program tree filip mazowiecki joanna ochremiak adam witkowski univers warsaw abstract studi problem elimin recurs monad datalog program tree set label bounded problem determin datalog program equival nonrecurs undecid decid regain descend relat disallow restric tion decid problem equival nonrecurs program investig connect problem detail introduct logic fixpoint capabl promin datalog augment union conjunct queri posit existenti order formula recurs datalog origin declar program lan guag applic databas queri languag gain express power free compar union conjunct queri evalu datalog program harder basic properti contain equival undecid sourc difficulti deal datalog program recurs natur attack optim program elimin recurs well nonrecurs datalog program rewritten union conjunct queri main focus paper equival recurs datalog program union conjunct queri exampl program exampl work databas binari predic like unari predic trendi consid pair datalog program buy like buy trendi buy buy like buy trendi like program recurs second rule refer predic buy equival nonrecurs program consid hand pair program buy like buy buy buy like buy like equival nonrecurs program program equival nonrecurs program exampl present approach eliminat ing recurs datalog program determin datalog program equival nonrecurs datalog program decid datalog program equival nonrecurs program problem bear similar general separ decid call bounded problem negat full datalog fuel interest restrict restrict includ monad program unari predic head rule linear program intension predic rule connect program rule variabl mention connect paper monad datalog program consid cosmadaki program bounded problem decid techniqu prove contain problem monad datalog program decid addit assumpt bounded problem equival problem paper studi connect monad datalog program restrict tree structur databas model finit tree node carri label infinit alphabet test equal structur problem equival union conjunct queri undecid bounded problem und cidabl case regain decid problem absenc descend relat rank tree equival bounded problem decid exptim unrank tree prove equival linear program recurs expspac complet finish analysi connect equival bounded problem assump tion equi decid organ introduc datalog program basic definit deal problem equival recurs datalog program analyz bounded problem final explor connect approach elimin recurs datalog program assump tion aris decis problem equi decid conclud direct futur limit proof move appendix preliminari paper work finit tree label letter infinit alphabet tree unrank default work rank tree standard notat axe stand child descend relat assum node label binari relat hold node ident label unari predic hold node label descript syntax semant datalog detail datalog program relat signatur finit set rule form head bodi head atom bodi empti conjunct atom written comma separ list variabl bodi head implicit quantifi existenti size rule number variabl appear relat symbol predic fall categori exten sional predic explicit store databas head rule set alphabet infinit program finit subset denot intension predic head bodi defin rule program evalu generat atom intension predi cate infer under structur tree appli rule repeat point satur infer atom wit ness proof tree atom infer rule intension atom wit proof tree root label chil dren root proof tree atom intension predic bodi root children design predic call goal program will identifi goal predic program write goal predic program hold node evalu databas program unari relat hold databas program contain program contain hold way program equival exampl program comput node reach label path node child ident label descend label label intension predic goal proof tree center wit hold root tree notion proof tree paper datalog general struc ture exampl proof tree illustr pro gram evalu general structur proof tree find model proof tree wit correct evalu pro gram tree structur simpl reason allow label node result rule satisfi node uniqu father easi determin proof tree wit evalu program model suffic elimin unsatisfi rule proof tree model exist will call satisfi proof tree exampl program tree path label tree find node label proof tree satisfi second proof tree satisfi enforc label node paper consid monad program program intension predic unari paper assum program ari intension predic general program sake simplic turn ari predic unari predic introduc dummi variabl connect program describ restrict matter datalog rule graph vertic variabl edg bodi atom formula distinguish head node intension node variabl bodi intension predic program connect rule graph connect previous work datalog arbitrari structur consid case connect program practic reason real life program tend connect rule connect combin piec consid allow addit node connect equal relat expect hard disconnect case main problem leav open equival child linear program undecid boolean queri unrel data correspond cross product unnatur oper databas context natur assum connected work tree structur databas write datalog class connect monad datalog program datalog con nect monad program relat datalog program linear hand side rule atom intension predic proof tree program singl branch linear program letter datalog linear program datalog program exampl con nect linear program exampl connect linear conjunct queri cqs existenti order formula form conjunct atom will consid union conjunct queri ucq correspond nonrecurs program singl intension predic goal bodi rule ucq datalog program speak connect ucq datalog assum connected denot class connect queri ucq ucq equival datalog program contain problem reduc equival problem datalog program ucq iff notic reduct depend type program disallow relat assum linear reli fact datalog program close disjunct contain problem datalog program studi tree context contain datalog program ucq data tree analyz detail boolean queri queri return answer satisfi node databas answer formal datalog program defin boolean queri pbool equal iff nonempti contain problem solv consid dual problem unari queri question exist databas andx boolean queri question exist databas datalog program tree allow relat distinct differ intuit move node node closer proof theorem proposit proposit rank unrank tree contain problem datalog program ucq undecid rest work fragment datalog relat start rank tree theorem contain problem exptim complet datalog rank tree special case pspace complet result yield tight complex bound equival prob lem datalog program ucq program rank tree prove theorem appendic defin automata simul behavior datalog program modifi approach construc tion better complex linear rest focus equival problem datalog program ucq program unrank tree contain prob lem question left open boolean queri contain problem datalog program ucq program prove undecid decid restor linear fragment exptim complet improv complex unari queri techniqu appen dice theorem contain problem datalog program ucq program expspac complet unrank tree approach general linear case hand proof undecid provid adapt work leav question decid contain linear program open problem lemma prove appendix assum linear lemma contain problem ucq queri datalog nptime rank unrank tree corollari theorem lemma main result lower bound carri contain problem theorem equival problem datalog program ucq program expspac complet unrank tree bounded consid datalog program goal predic denot collect fact predic deduc databas applic rule formal subset linear case requir addit exponenti blow improv complex caus consid unari boolean queri easi theorem hold boolean case main idea undecid proof ucq error ture machin encod program nonrecurs queri unari error close node deriv proof tree height height tree length longest path root leaf program bound exist number depend databas intuit depth recurs independ input proof tree correspond conjunct queri natur fore translat datalog program equival infinit union conjunct queri program bound equiva lent finit subunion correspond conjunct queri full datalog opposit implic true program bound iff equival finit ucq hold class datalog proposit datalog bound iff equival union conjunct queri ucq remark character prove appendix base exist call canon databas cqs datalog exampl canon databas equival ucq impli bounded reli fact transit closur exampl program datalog left bound find ing tree arbitrarili long program ucq equival negat result datalog appendix theorem bounded problem datalog undecid rank unrank tree work fragment datalog relat decid automaton theoret approach theorem bounded problem datalog pspace observ interest output goal predic properti consid call predic bounded case tree techniqu appli complex creas appendix theorem bounded problem datalog rank tree exptim relat interpret posit posit posit word neighbourhood infix posit max end posit min lemma motiv proposit proof provid appendix lemma datalog program bound iff exist word posit neighbourhood proof theorem word posit neighbourhood will call wit lemma datalog program unbound iff exist wit arbitrarili big consid datalog program alphabet set label explicit rule fresh label size biggest rule easi verifi word relabel word label posit iff true respect infix infix posit hold iff correspond infix verifi exist wit finit alphabet proof theorem appendix nondeterminist automaton introduc recogn alphabet satisfi precis construct automaton work alphabet accept word iff exact posit mark denot languag recogn size automaton exponenti size automaton recogn phabet exact posit mark belong size exponenti size exponenti blow construct appendix altern automata languag recogn will denot note languag close infix mark posit defin nondeterminist automaton accept exact belong infix belong state transit state transit product automaton state transit copi automaton denot qinit initi state state add epsilon transit state state qinit product automaton set final state state qfin add epsilon transit state qfin initi state initi state final state final state accept automaton start move product automaton point read infix belong final accept number state product automaton suppos accept wit pump lemma accept wit arbitrarili big proof check accept wit nlogspac size automata pspace size wit word belong neighbourhood posit mark belong nlogspac algorithm simul automaton size exponenti size state transit generat fli polynomi space algorithm guess state check reachabl initi state simpl reachabl test nlogspac guess count number transit mark ensur transit mark ensur automaton transit leav count procedur log tape cell final algorithm perform second reachabl test check automaton reach final state three way wit simplic algorithm describ deal case neighbourhood belong shorter happen posit end posit possibl verifi notic bound proof bound depth recurs size construct automaton exponenti size program ucq equival program consist proof tree size exponenti size bounded equival focus similar bounded equival problem datalog program section problem treat separ techniqu bounded equival consid monad program arbitrari structur problem solv automata theoret construct reason investig connect problem detail contrast previous section structur consider tree definit class datalog program fix class databas call well behav program ucq correspond proof tree belong contain ucq datalog program decid condit satisfi natur class program class datalog program arbitrari structur class datalog tree class datalog program arbitrari structur condit hold true lemma class datalog tree satisfi condit class well behav comput bound exist comput func tion datalog program bound databas bound program function return bound depth recurs program bound return arbitrari natur number exampl consid full datalog class monad datalog program arbitrari structur comput bound state explicit closer analysi proof bound program depth recurs bound polynomi size automaton construct check bound exampl linear connect program size automaton bound exponenti size program theorem well behav class comput bound establish connect problem bounded equival ucq theorem well behav class comput bound follow ing condit equival bounded decid decid program equival ucq proof function definit comput bound implic program belong assum ucq well behav decid contain assumpt verifi bound case observ equival ucq correspond proof tree height remain decid ucq contain suppos bound consid unionr programsp formal program rule program predic occur program renam predic coincid goal predic hold iff introduc addit rule atom infer step unbound exist satisfi hold contain bound construct equival ucq check equival case contain implic consid datalog programp bound iff databas ucq correspond proof tree height suffic decid program equival decid assumpt well behav assum class program well behav natur exist comput bound strong assumpt need algorithm solv bounded problem construct mean big equival ucq decid function exist hard solv bounded problem ampl monad program arbitrari structur exist construct algorithm bounded problem putabl bound hand undecid bounded problem datalog arbitrari structur reli heavili fact comput bound exist author reduct halt problem counter machin ture machin dat alog program bound size equival ucq correspond length accept machin cours bound comput function paper sens posit provid comput bound negat reli fact function exist reason conjectur well behav class datalog program decid bounded problem equival decid find comput bound conjectur hold true theorem implic opposit implic trivial satisfi conclus equival nonrecurs program bounded problem datalog undecid regain decid consid program relat equival ucq rank tree decid unrank tree decid case linear program decid bounded rank tree general case linear datalog program unrank tree problem consider decid leav question open problem investig connect bounded equiv alenc ucq problem equival decid class program comput bound suspect exist comput bound class program equival decid bounded problem leav open problem refer serg abiteboul pierr bourhi anca muschol zhilin recurs queri tree data tree icdt serg abiteboul richard hull victor vianu foundat databas dison wesley franc bancilhon raghu ramakrishnan introduct cursiv queri process strategi acm sigmod michael benedikt pierr bourhi pierr senellart monad datalog ment icalp miko laj bojan czyk filip murlak adam witkowski contain monad datalog program bound cliqu width accept icalp piero bonatti decid contain recurs datalog queri preliminari report pod diego calvanes giusepp giacomo mosh vardi decid ment recurs queri theor comput sci stefano ceri georg gottlob letizia tanca logic program databas springer verlag york ashok chandra harri lewi johann makowski embed plicat depend infer problem stoc ashok chandra philip merlin optim implement conjunct queri relat data base stoc surajit chaudhuri mosh vardi equival recurs recurs datalog program pod stavro cosmadaki haim gaifman pari kanellaki mosh vardi decid optim problem databas logic program preliminari report stoc stavro cosmadaki pari kanellaki parallel evalu recurs rule queri pod andr frochaux martin grohe nicol schweikardt monad datalog con tainment tree proceed alberto mendelzon workshop foundat data manag haim gaifman harri mairson yehoshua sagiv mosh vardi undecid optim problem databas logic program acm gerd hillebrand pari kanellaki harri mairson mosh vardi undecid bounded problem datalog program log program filip mazowiecki filip murlak adam witkowski monad datalog reg ular tree pattern queri mfcs naughton data independ recurs deduct databas syst sci naughton yehoshua sagiv simpl character uniform bounded class recurs log program yehoshua sagiv optim datalog program foundat deduct databas logic program morgan kaufmann ode shmueli equival datalog queri undecid log program mosh vardi complex relat queri languag extend abstract stoc definit automata paper decid automata construct recal standard automata model rank tree bottom tree automaton ari tree consist finit alphabet finit set state set accept state transit relat tree label element consist transit relat children labt leaf accept assign state root tree accept admit accept languag recogn denot set accept tree recal test empti tree automaton ptime complement involv exponenti blow special case model test empti nlogspac intermedi automata model closer datalog bottom automata altern automata introduc altern automaton consist alphabet finit set state initi state transit function describ action automaton state node label posit boolean combin atom action form tree tree label pair state node satisfi condit root label pair consist root node label children label label exist child parent boolean combin evalu true atom action substitut true atom action substitut fals tree accept automaton admit finit denot languag recogn set tree accept definit altern automata distin guish stay general model appropri order rank tree distinguish child second child datalog program distinct simplifi definit suffic comput model altern automata datalog program make perfect intermedi formal road nondeterminist bottom automata continu fact proposit altern automaton interpret rank tree comput time polynomi size input output singl exponenti nondeterminist bottom automata recogn languag complement notic complement altern automata trivial infinit run accept canon model homomorph satisfi rule datalog program recal graph node pattern node edg type edg node distinguish node label variabl name extension unari predic rule replac label simul relat repeat variabl label set relat disallow transform satisfi rule equival rule tree model tree node common child merg node exampl rule transform tree version pattern correspond rule repeat occurr repres relat pattern homomorph pattern model tree function node preserv extension predic proof tree wit evalu program model iff rule homomor phism pattern intension node map node head node rule connect pattern datalog explain detail satisfi proof tree canon model chang rule pattern merg head node intension node node label variabl relabel fresh label preserv equal forc graph pattern proof tree turn tree exampl easi suffic consid contain problem canon model model wit proof tree canon model correspond proof tree model equival decid contain construct automaton empti iff counterexampl contain mark singl node tree automaton verifi goal predic program question satisfi node formal extend alphabet product recogn model exact node mark tight complex bound altern automata techniqu special case relat interpret posit posit lemma datalog finit alphabet exist altern automaton accept exact posit label hold posit automaton construct time polynomi proof program datalog finit alphabet alphabet time second compon ignor work consid connect program loss general assum rule form conjunct atom unari predic pattern corr spond bodi word automaton defin allow tran sition general form transit function assign state letter pair posit boolean combin element fix constant semant natur automaton move posit left depend sign chang state general automaton transform standard cost enlarg state space factor case will bound maxim number variabl rule describ automaton state space consist letter rule addit initi state transit relat defin initi state current letter loop move reach posit word start evalu rgoal rgoal goal rule case ignor compon alphabet requir second compon goal rule appli state current letter check bodi match input word map current posit rang label intension atom set rule defin intension predic state simpli check letter current posit check correct size bound pose difficulti product automaton size linear check exact posit label automaton statement proof theorem case proof theorem proposit suffic check satisfi alphabet linear size program altern automata lemma automata proposit determinist automata exponenti size recogn languag complement easili product automaton equival queri accept exact posit mark size exponenti size state transit generat fli polynomi space check empti simpl reachabl test nlogspac altogeth pspace algorithm rank tree lift rank tree complex higher general pictur remain lemma datalog program rule size finit alphabet exist altern automaton size recogn tree exact node label hold node proof program datalog finit alphabet interest tree alphabet elimin rule replac rule variant replac size program grow factor size rule grow constant factor work tree transform program pattern correspond rule program tree node posit arbitrarili unifi variabl rule variabl remov rule atom atom variabl distinct letter exampl modif increas size program final rewrit rule set rule form axi axi conjunct monad intension atom rule test label intension predic current node demand exi tenc neighbour children parent satisfi intension predic modif introduc auxiliari intension predic size program icreas factor program essenti altern automaton syntax automaton statement modifi automaton case proof theorem tree theorem tree suffic verifi contain finit alphabet exponenti size lemma proposit reduc contain problem empti problem nondeterminist tree automaton doubl exponenti size test empti standard ptime algorithm lower bound straightforward modif satisfi unrank tree proposit satisfi problem datalog unrank tree exptim prove result introduc notat definit finit alphabet univers tree full ari tree leaf node child label will denot uan univers tree height root fig univers tree proof will proceed will satisfi satisfi univers tree easi combin lemma proposit set univers tree satisfi regular recogn automaton number state doubl exponen tial linear program better exptim algorithm lemma datalog finit set label program satisfi iff satisfi univers tree proof suffic satisfi satisfi univers tree direct obvious model recal set constant chang label singl label chosen preserv equal datalog program negat oper set bigger perform oper node children label merg children node node children merg node easi check oper preserv homomorph chang empti set appli procedur sibl label final add node tree univers tree cours node decreas set finish proof assum linear program will prove stronger result will decid contain datalog program ucq will algorithm calcul way evalu program univers tree evalu root tree introduc notion partial match datalog pro gram rule match tree homomorph pattern proof word partial match program tree infix proof word rule match complet partial match imag intension node equal head node partial match repres pair partial homomor phism pattern rule infix proof word interest partial match map node pattern root tree partial homomorph repres partial function pattern cours partial match node map root tree partial match extend situat goal rule match recurs rule posit leav addit symbol mark situat denot set partial match match size match exponenti size suffic calcul set partial match tree determin satisfi lemma finit alphabet set partial match match root univers tree calcul time exponenti linear program proof tree will denot set partial match root match observ partial match uan partial match uan match monoton match match uan observ yield simpl algorithm dif ferent univers tree height calcul match uan suffic join partial match match root node label add calcul match uan note match uan match match match describ procedur requir match step termin step take match time exptim gorithm proof upper bound theorem datalog program letq ucq goal determin databas solv dual problem counterexampl contain databas node assum canon model size biggest conjunct nonrecurs connect determin suffic check subtre node distanc refer posit queri negat queri defin automaton essenti recogn satisfi proof simultan check negat queri satisfi canon model read word alphabet set rule program defin set state cartesian product three compon describ compon separ recal denot set constant explicit rule program size biggest rule alphabet letter alphabet letter disjoint compon automaton store label pattern correspond ing current read letter rule formal identifi pattern set node set pattern node label element set intend mean will explain second compon automaton store word length posit compar node formal set length label word represent ancestor path start intension node current pattern store verifi proof word satisfi ancestor path arbitrari long will rememb node distanc node addit automaton rememb path lay compar store pair number common ancestor number denot distanc number denot distanc note distanc descend descend compon set partial homomorph pattern correspond cqs negat queri word store second compon set conjunct formal set partial function interpret label will explain defin transit relat suppos automaton read letter previous state automaton calcul state compon automaton start check rule proper intension predic previous rule letter automaton check goal predic case hold automaton reject word label phase phase label head node label intension node label node ancestor match correspond label path automaton label node explicit label second phase automaton guess remain label respect relat node forc label automaton reject word small alphabet repres arbitrari larg set label state label state forc assum canon model label second compon automaton updat pair agre locat intension node respect creat ancestor path label agre label path label node ancestor case distanc intension node bigger explain compon automaton start updat partial function label appear phase replac intend mean label longer appear model crucial featur canon model fresh label automaton forget label will longer appear automaton forget partial homomorph unmap node label forc equal node label homomorph fulfil automaton extend remain homomorph node label denot fact node map correspond node path step relabel partial homomorph agre path automaton extend homomorph note partial homomorph discard extend time homomorph full homomorph automaton reject word explain behavior letter proof word intension node distanc cours case notic node bigger distanc impact negat queri satisfi problem suppos automaton read letter intension node distanc bigger automaton updat third compon state usual reject word full homomorph ancestor intension node distanc automaton assum univers tree alphabet definit calcul set match find match rule rule node root automaton choos match rule intension node proceed eventu automaton guess match intension node rule distanc store updat state usual rule automaton accept word notic node exist common ancestor intension node distanc bigger situat occur assum work canon model node rule will distanc bigger suffic check satisfi start rule modifi canon model univers tree posi tive program lemma univers tree negat program assur chang node distanc bigger construct automaton empti iff canon model bound size set state compon label rule exponenti size number rule bound size second compon set tripl number word size exponenti size third compon powerset partial homomorph doubl exponenti size andq automaton bound doubl exponenti state transit generat fli exponenti space check empti simpl reachabl test nlogspac satisfi generat transit proposit exptim altogeth algorithm expspac proof lower bound theorem consid satisfi problem datalog ucq prove hard number ture machin construct datalog program size polynomi satisfi iff accept empti word tape cell program will encod machin program will ensur correct assum tape alphabet set state set accept state transit relat finit alphabet program will set symbol will mark posit head tape state machin defin rule posit program program start node label encod configur current state tape content enforc full binari tree hight alphabet set predic denot left son previous node tape encod node leaf tree label node root tree identif encod configur will refer identif node goal rule init conf encod initi configur machin identif node label init store tree note init belong program will travers configur tree infix order conf downlefti downlefti downleftn store store upleftn store uprightn symbol uplefti downrighti downrighti downlefti uprighti uprighti uprighti uplefti observ reach downleftn travers tree program rule store write content tape rule downrightn program finish travers tree con figur machin ensur identif node configur label root tree encod pre vious will enabl negat program check correct encod conf finish find accept state letter recurs rule store store defin rule negat program will dis junction queri describ error encod content tape defin uniqu pair symbol rule ensur configur tree identif node label differ guarante tree label identif node encod configur pair symbol introduc rule easili enforc configur tree label init encod initi configur machin empti word store tape final sure posit program move configur consist transit function machin consid chang content three consecut tape cell tupl symbol encod content three consecut tape cell machin posit configur tupl set rule rule construct depend common ancestor three leaf encod consecut tape cell write rule deal case common ancestor root tree rule deal case common ancestor label proof lemma program datalog andq ucq queri consid pattern pattern correspond tree uniqu renam label explicit mention addit mark node correspond head node remain check hold tree well combin complex monad program nptime complet suffic guess proof tree verifi correct guess bounded proof proposit obvious suppos datalog program equival union conjunct queri rule consid pattern pattern associ set tree homomorph imag renam label explicit mention finit tree connect relat evalu program tree biggest number applic rule tree will consid node program equival hold wit homomorph applic rule deriv fragment undecid bounded problem general proof theorem will reduc problem ture machinem arbitrari long run ofm start empti tape halt state denot halt problem undecid machin transit state symbol tape halt state add transit stay state read chang posit head halt modifi arbitrari long halt run ture machin assum loss general tape semi infinit will construct program program will find encod empti input tree will detect error encod program will equival union ucq will ensur correct correspond encod program will altern tree error encod will hold node tree step comput qill equival ucq construct program will bound ifm arbitrari long halt run ofm will encod word describ consecut configur configur will separ symbol encod will start symbol will denot posit tape will encod consecut node will denot row number number row column number encod tape symbol will mark denot head posit consid tree encod will tree node upward root program will path match tree correct encod guarante transit will set rule verifi consecut encod configur consist singl rule will verifi content tape copi chang correct configur ensur rule will consecut posit tripl tape symbol will rule match posit encod tape symbol rule true posit describ direct symbol symbol configur posit consist head tape symbol copi head posit symbol chang configur head tape configur exampl posit head configur head inspect posit will rule tape symbol quadrupleri variabl describ posit tape configur configur column symbol store posit addit will rule chang row check posit ensur row length pre vious posit longer node depend movement head will rule final row encod reach halt state pfin pfin will will true root tree label pfin match program qerr altern error encod qerr qerr qerr note necess tripl altern proper descend relat hold hold node tree qerr error tape symbol appear wrong posit exampl detect symbol colum number qerr qerr rule construct row row tape symbol consecut symbol detect qerr node appear detect qerr node appear start detect byqerr start row number row detect qerr column number row detect qerr program work row distinct row number ensur previous rule easi match node tree describ error root node databas correct encod halt comput databas take number step linear proport length encod unbound arbitrari long halt properti bounded rank tree proof lemma implic bound equival union conjunct queri queri connect size biggest queri implic assum satisfi condit exist word posit neighbourhood will construct union conjunct queri equival recal denot set label appear rule program consid length smaller equal treat structur signatur finit equal type word satisfi add queri defin equal type remain equival contain straightforward construct word posit neighbourhood word lenght move case tree state lemma equival lemma rank tree tree neighbourhood node subtre consist node distanc lemma datalog program rank tree follow ing condit equival bound exist tree node neighbourhood proof proof analog proof lemma rank consid tree implic notic finit equal type respect tree height finit equal type neighbourhood equal type neighbourhood defin ucq equival union contain case tree defin wit tree exist node neighbourhood wit tree wit corollari datalog program rank tree unbound iff exist wit arbitrarili big proof theorem restat theorem bounded problem datalog rank tree exptim proof prove theorem bounded verifi rank tree finit alphabet lemma datalog program bound rank data tree rank iff bound rank tree rank finit alphabet alphabet proof proof slight modif proof bound clear bound finit subset suppos bound bound equival ucq built finit number proof tree node will relabel tree preserv label comparison rule union proof hold iff contradict equival rank tree size largest rule set size set will describ procedur travers tree top fashion level level chang label element set process node consist full level start root node level node level process node edg tree root close root suppos label finish process assum pick label appear process descend find label number process descend includ bound number label node fresh label replac appear unprocess descend node observ node separ node label distanc replac appear unprocess descend distanc node node label modif affect outcom label comparison rule short axi connect node process label finit alphabet previous lemma construct automaton recogn set wit lemma altern tree automaton work accept set tree node label goal predic satisfi node size automaton exponenti bottom automaton recogn proposit automaton prod uct bottom automaton recogn complement proposit automaton check node tree label accept tree hold mark node size doubl exponenti automata construct easi set state denot set state automaton tree denot mark node automaton start state initi state simul node tree automaton guess neighbourhood hold chang second compon state initi state simul guess neighbourhood verifi hold reach accept state guess node root neighbourhood chang state second compon accept state state accept state word case exist wit size linear size automaton exist arbitrarili big wit lemma number state automaton exist wit exist wit arbitrari larg exist wit decid time polynomi proof pump argument word case time arbitrarili big wit pump path neighbourhood satisfi suppos exist wit mark node path length state ofwp repeat pump context node notic path shorter wit leaf tree pump path path upward length state repeat pump context occurr state time extend path start pump fragment return path length size neighbourhood pump shorter leaf tree verifi exist wit modifi automaton counter automaton guess neighbourhood leaf node start count length shortest path common ancestor reach automaton node calcul length shortest path minimum valu counter calcul children counter chang neighbourhood leaf tree length path automaton set counter suffici length second counter node path count length path node node guess neighbourhood counter difficult counter accept condit modifi automaton accept iff exist wit empti decid time linear size automaton claim size ofwp doubl exponenti exptim procedur decid bounded 