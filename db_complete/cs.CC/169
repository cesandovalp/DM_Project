subtre isomorph revisit amir abboud stanford univers abboud artur backur mit backur thoma dueholm hansen aarhus univers tdh virginia vassilevska william stanford univers virgi zamir tel aviv univers orzamir abstract subtre isomorph problem ask tree contain tree problem fundament studi variant order tree linear time algorithm general case subquadrat algorithm remain elus result reduct orthogon vector problem subtre isomorph show subquadrat algorithm refut strong exponenti time hypothesi seth light condit lower bound focus natur special case subquadrat algorithm classifi case quadrat barrier show binari root tree subquadrat algorithm refut seth root tree depth log log total number vertic subquadrat algorithm refut seth constant constant random subquadrat algorithm degre root tree depth logd min algorithm binari tree depth reduct util tree gadget futur seth base lower bound problem tree upper bound appli folklor result random decis tree complex introduct tree frequent common studi object comput scienc basic fundament comput problem tree tree contain isomorph copi delet node edg support nsf grant ccf ccf bsf grant bsf support nsf simon foundat work author thoma watson center support carlsberg foundat grant support bsf grant isra center excel core program center problem three name subtre isomorph tree pattern match subgraph isomorph tree variant problem determin tree root unroot degre bound tree order order children node preserv isomorph paper focus case root unord tree degre bound constant fundament time complex subtre isomorph studi matula edmond problem interest special case subgraph isomorph problem studi extens theoret comput scienc subgraph isomorph well hard general hard problem cliqu notori difficult natur complet problem requir time exponenti time hypothesi eth special case subgraph isomorph receiv extens attent paper marx pilipczuk cover case fix constant size fix size trivial way problem polynomi time solvabl subtre isomorph earliest arguabl natur polynomi time algorithm biconnect outerplanar graph connect seri parallel graph general hard forest binari tree problem practic relev model applic wide varieti area subtre isomorph core express problem largest common subtre general tree applic area includ comput biolog structur text databas compil optim definit tree similar propos search fast algorithm comput theori practic ongo decad survey textbook focus subtre isomorph discuss techniqu introduc paper adapt prove largest common subtre problem well previous matula algorithm subtre isomorph propos independ edmond matula year reyner matula algorithm polynomi time runtim algorithm execut call subroutin solv maximum match bipartit graph result root tree chung bound achiev unroot tree linga shave log factor develop shamir tsur random algorithm bipartit match reduc runtim matrix multipl expon interest basic case root constant degre tree earli algo rithm time fastest runtim log comparison tree order long stoc foc paper brought complex problem quadrat log time natur wonder improv achiev case unord tree main main result condit lower bound subtre isomorph subquadrat algorithm restrict case binari root tree root tree depth log log match upper bound factor discuss algorithm lower bound condit well strong exponenti time hypothesi seth impagliazzo paturi zane rough state grow sat variabl requir poli time result subtre isomorph seth hard problem tree excit addit divers includ problem vector general graph sequenc curv idea construct tree gadget prove condit lower bound problem tree demonstr lower bound largest common subtre problem discuss theorem subtre isomorph root unord tree size degre height logd log log solv subquadrat time seth general size smaller tree bigger tree lower bound time refut seth remark seth believ hold random algorithm lower bound barrier subquadrat random algorithm complement lower bound proceed tackl natur restrict problem algorithm natur restrict tree input bound degre height lower bound leav room improv binari tree height log algorithm quadrat time seth note minimum height binari tree log intrigu case tree binari complet log unabl super linear lower bound case determinist algorithm run subquadrat time random las vega algorithm solv case subquadrat time algorithm solv general case theorem random algorithm root subtre isomorph expect ning time min tree size height algorithm run time tree depth subquadrat tree depth algorithm simpl natur easi implement interest upper bound techniqu techniqu random decis tree complex consid case ternari tree provid fast las vega algorithm approach binari tree case comput program analyz expect run time algorithm theorem random algorithm solv subtre isomorph root ternari tree size height expect min time problem upper bound algorithm refut seth final general algorithm subquadrat algorithm root subtre isomorph tree small height constant degre theorem random algorithm solv subtre isomorph root tree size constant degre height expect time min algorithm subquadrat tree height log log logd constant bound theorem tight small algorithm exampl subquadrat small depth tree upper bound prove random queri complex upper bound bipartit perfect match independ interest lemma work exampl fine grain studi complex fundament problem natur parameter approach formal work techniqu prove seth hard reduct orthogon vector subtre isomorph reduct follow previous seth hard spirit requir care construct tree gadget repres vector well techniqu combin gadget big tree exist orthogon pair vector determin contain reduct clean simpl tricki restrict tree constant degre reduct easili modifi lower bound problem largest common subtre tree lcst problem hard number tree paramet tree label unroot approxim parameter algorithm tree binari unlabel problem solv quadrat time adapt theorem height log subquadrat algorithm refut seth theorem largest common subtre problem root tree size degre height logd log log solv subquadrat time seth theorem surpris contrast hand arbitrari root tree constant degre subtre isomorph harder lcst tight quadrat upper condit lower bound hand restrict tree small depth theorem subtre isomorph solv subquadrat time theorem lcst problem seth attribut algorithm ingredi ingredi lower bound notic tree binari depth log difficult implement reduct turn attent find upper bound know hard case allow focus solvabl case byproduct condit lower bound second ingredi make connect problem semin result random decis tree complex algorithm binari ternari tree inspir well result complex theori formula repres complet tree leav repres variabl evalu formula input surpris fact random evalu gate guess child check random input gate input gate check child evalu formula input result applic area complex theori learn theori quantum queri complex work late subtre isomorph consid viewpoint effici parallel algorithm linga karpinski problem random gibbon miller karp sorok independ result reduct bipartit match subtre isomorph reduct take match instanc node produc tree node impli lower bound time complex subtre isomorph assum current match algorithm optim note reduct match input size will generat tree size quadrat lower bound reduc problem orthogon vector case problem solv linear time exampl tree exact size tree isomorph problem solv time hopcroft tarjan linear time algorithm suggest refer exampl case order tree mean order children node modifi isomorph subtre defin node descend subtre isomorph solv linear time seth lower bound strong exponenti time hypothesi seth state exist sat variabl solv npolyn time william seth polynomi time problem call orthogon vector input list vector output pair vector list orthogon equal william reduc cnf sat solv time logn cnf sat variabl poli claus solv npoli time seth fals reduc cnf sat orthogon vector problem variant subtre isomorph problem prove seth base lower bound hard subtre isomorph simpler reduct start warm reduct present high level idea proof theorem reduc subtre isomorph tree vertic unbound degre height chang construct tree small constant degre small height theorem orthogon vector list vector reduc subtre isomorph tree size depth proof denot vector list second list recal goal find pair vector coordin ingredi reduct construct vector gadget vector list creat vector gadget tree size add path root coordin consid add node tree child node add edg child will defin vector gadget vector second list creat vector gadget tree size step add path root differ second step coordin consid add node child node add edg simpl claim key reduct explain gadget construct claim isomorph iff orthogon proof direct assum orthogon will defin map subgraph edg edg map root path set consid map node guarante exist orthogon vector easi check neighbour map neighbour direct assum isomorph subgraph map note map root tree observ map path map path path length tree note degre case impli degre impli node exist case vector orthogon final step combin vector gadget tree isomorph subtre pair orthogon vector list defin special vector vector dimens claim vector isomorph subtre readi defin tree size will compos root node degre child addit distinct gadget add vector gadget add edg root add tree add edg root will construct add vector gadget creat root node degre child definit add edg root prove correct reduct note size tree gadget size combin gadget tree conclud proof claim isomorph subgraph iff pair orthogon vector claim reduct isomorph subtre iff pair orthogon vector proof direct assum pair orthogon vector will isomorph subtre consid map map claim subtre map subtre final root map easi check neighbour map neighbour direct assum isomorph subgraph correspond map vector gadget imag map entir contain exact vector gadget gadget map gadget gadget gadget pigeonhol principl map gadget conclud map neighbour map neighbour isomorph subgraph claim impli orthogon shorter vector gadget reduct implement tree smaller depth introduc construct vector gadget will gadget final reduct prove theorem lemma vector construct binari root tree depth linear time isomorph subtre orthogon proof construct will involv care combin gadget defin sequenc binari valu defin tree gadget bit repres compos path length root attach child gadget repres natur edg will exist vector gadget construct build complet binari tree leav subtre leaf will encod entri gadget assum repres bit denot represent denot binari sequenc flip bit node will attach three gadget will attach gadget follow gadget final append path length depend necess complic encod will clear proof correct formal attach denot node correspond construct node path attach node correspond construct node path attach three node attach node second vector gadget construct attach path length oppos attach path length construct depth tree claim complet proof isomorph subtre iff direct easi vector orthogon natur map construct isomorph map binari tree top map map attach subtre final map path case will exist remain isomorph subtre gadget will play crucial role will map leav complet tree map gadget will map proper claim indic contain contain true observ isomorph subtre iff set posit subset set posit map subtre map path repres path repres construct happen constant degre tree challeng element proof theorem combin vector gadget big tree larg degre difficulti recal reduct proof theorem tree vector gadget children root degre essenti allow isomorph pick match gadget combin auxiliari gadget allow final tree instanc subtre isomorph origin vector contain orthogon pair tree constant degre binari harder combin vector gadget tree match gadget chosen isomorph natur approach add gadget leav complet binari tree reason work isomorph map second gadget adjac gadget second tree special kind match implement overcom difficulti level construct allow isomorph pick exact gadget tree match gadget affect outcom theorem set vector construct root tree properti hold number node tree construct time upper bound degre tree upper bound depth tree upper bound logd logd isomorph subtre iff proof set vector gadget correspond vector construct lemma will combin vector gadget big tree will construct differ assum logd integ add dummi vector increas tree will compos complet ari tree leav path length logd vector gadget formal add logd construct second tree construct vector gadget correspond vector length start complet ari tree leav attach path length logd leaf will treat differ attach copi path copi total formal add logd note vector second list encod will appear subtre root construct root add complet ari tree leav attach vector gadget leav add finish construct properti third properti lemma turn prove fourth properti correct construct claim pair vector isomorph subtre proof direct pair orthogon vector will contain consid rearrang rightmost leaf complet ari tree node vector gadget attach claim vector gadget proper map subtre rearrang node note vector gadget will pair vector gadget lemma fact orthogon vector proper map remain subtre root contain subtre root map vector gadget vector gadget second direct assum map subtre will exist pair orthogon vector note map map construct subtre root vector gadget map vector gadget lemma happen theorem connect seth william impli theorem introduct hard largest common subtre prove lower bound largest common subtre lcst problem gener aliz subtre isomorph reduct impli quadrat lower bound lcst will optim reduct prove stronger hard result will binari tree depth log lcst comput subquadrat time will interest gap lcst subtre isomorph solv subquadrat time tree upper bound strengthen hard result explan extend upper bound lcst extens refut seth theorem impli theorem introduct theorem largest common subtre problem tree size solv time orthogon vector vector solv time tree produc reduct orthogon vector problem degre height logd logd arbitrari proof note construct provid theorem suffici purpos height produc tree logd logd larger will express natur lcst implement reduct smaller height achiev smaller height will implement vector gadget largest common subtre gadget fix size vector orthogon will larger size vector orthogon trick introduc backur indyk reduct edit distanc reduct lcs care implement gadget degre tree small height sequenc wlog assum vector start vector start add extra coordin vector set entri chang answer problem orthogon vector assum vector number entri equal subdivid set smaller set set vector number entri equal reduct subset increas runtim solv orthogon vector problem factor fine vector list construct vector gadget vector gadget construct lemma correspond vector equal root vertex root vector second list construct vector gadget vector coordin entri equal rest entri equal vector gadget construct lemma correspond vector choos vertex root main idea construct match choic match fix score independ match score depend orthogon argument formal lemma denot size independ vector number lemma largest common subtre size orthogon size size equal proof orthogon lemma isomorph subgraph lcst size second case assum orthogon remark common subtre size denot set coordin equal subtre size lemma subtre remain map entir tree subtre isomorph subtre subtre readi final tree construct build complet ari tree leav lowest level add construct complet ari tree leav lower level add theorem largest common subtre size pair orthogon vector proof map node node gpi permut notic arbitrari permut permut implement swap children complet binari tree hand total size common subtre upper bound size complet binari tree leav lcst arbitrari permut pair orthogon vector lemma sum exact total size bound hand orthogon pair map map map arbitrarili induc permut map gpi lemma impli map complet map score lcst algorithm algorithm subtre isomorph root tree vertic bound degre edmond matula independ describ procedur reduc root subtre isomorph problem polynomi bound collect recurs smaller subtre isomorph problem combin answer solv maximum bipartit match problem follow approach focus case degre bound constant root tree decid isomorph subtre root map root subtre root children root root bipartit graph vertex set edg isomorph subtre isomorph subtre match size edmond matula procedur construct graph recurs solv maximum bipartit match problem design algorithm root subtre isomorph involv challeng con struct solv maximum bipartit match problem current fastest domiz algorithm maximum bipartit match problem mucha sankowski run expect time matrix multipl expon improv algorithm challeng open problem construct graph hard determinist algorithm edg random algorithm pair edg graph expect number node pair queri pair edg graph random algorithm order determin perfect match exist random queri complex decis tree complex bipartit perfect match easi exercis check random queri complex problem estim exact number queri straightforward clear queri expect queri suffici factor analysi maximum bipartit match algorithm complic thing simplifi thing restrict attent case degre tree bound constant case check constant time desir perfect match suffici number edg queri focus sole random queri complex bipartit match problem recurs algorithm subtre isomorph problem easi case algorithm edmond matula run time algorithm handl label vertic vertex label label requir match label subtre algorithm solv largest common subtre problem time well recurs assign weight edg equal size largest common subtre match largest weight refer appendix short complex analysi descript algorithm lower bound theorem tight tree constant degre remaind restrict attent tree constant degre height introduc random algorithm solv binari problem expect time min comparison correspond upper bound edmond matula min algorithm recurs call level tree algorithm subquadrat complic case analysi show problem solv expect time min improv straightforward min bound edmond matula introduc random algorithm expect run time upper bound min faster algorithm binari tree tree degre edmond matula procedur interpret left subtre left subtre isomorph subtre condit true isomorph subtre isomorph subtre isomorph subtre isomorph subtre case check recurs call check isomorph subtre recurs call upper bound observ isomorph subtre reason check isomorph subtre algorithm conclud condit met reason check second condit isomorph subtre base observ introduc simpl random variant algorithm achiev better run time save recurs call swap probabl swap probabl edmond matula algorithm perform unnecessari recurs call formal descript algorithm figur refer algorithm randbinarysubiso theorem randbinarysubiso algorithm run expect time min tree size height run time tree height subquadrat tree height prove theorem prove lemma maximum expect number time randbinarysubiso recurs call empti tree arbitrari root tree height tye tno defin assumpt algorithm return true fals note tye tno note max tye tno lemma tye tye tno tno tye tno algorithm randbinarysubiso return true return fals probabl swap probabl swap randbinarysubiso fals step randbinarysubiso true return true randbinarysubiso fals return fals randbinarysubiso true return true return fals figur random recurs algorithm root subtre isomorph binari tree proof simplifi notat write isomorph subtre tye tye tno assum probabl algorithm return true spend tye time expect hand probabl outcom line depend tree question recurs call line return true reach precis three case depend tree recurs call line return true algorithm spend tye time expect recurs call return fals recurs call line return true algorithm spend tno tye time expect iii recurs call return fals probabl true probabl second case recurs call return fals recurs call line return true algorithm spend tno tye time expect third case domin conclud tye tye tno tno tye tno assum contribut tno answer fals recurs call answer fals recurs call amount answer cost tno expect contribut tye probabl answer true fals probabl answer true fals total tno tno proof theorem lemma tye tno tye tno diagon matrix yield tye tno prove theorem faster algorithm ternari tree discuss subtre isomorph problem root ternari tree prove theorem show subtre isomorph root ternari tree height solv expect time binari case run time lower runtim generic algorithm constant degre tree binari case proof theorem proceed recurs approach recurs call consid random decis tree bipartit perfect match queri correspond recurs call height analyz runtim binari tree case distinguish case queri answer write run time recurr tye algorithm tree isomorph tno analyz random decis tree term expect number queri answer worst case random queri protocol partit bipartit match instanc subtre root tree subtre root pick random pick name swap probabl pick permut vertic yye zye zye yye xye zye xye figur decis tree bipartit match degre case probabl pick permut permut fix protocol determinist node node order chosen permut determinist decis tree depict figur choic answer edg queri match instanc consid random choic describ swap permut consid decis tree comput expect number call comput program establish instanc perfect match expect number call expect number call complement graph consist cycl disjoint singl edg hand instanc perfect match case domin expect number call expect number call expect number call expect number call option recurr relat domin recurr achiev maximum worst case expect runtim ternari case tye tno tye tno figur miss subtre decis tree bipartit match degre case diagon yield tye tno run time algorithm constant degre describ random save subtre comparison edmond matula algorithm degre recal algorithm work tree constant degre goal decid isomorph subtre recurs root children simpli view miss subtre special empti subtre subtre subtre build bipartit graph vertic left vertic connect isomorph subtre decid edg appear graph recurs output isomorph subtre perfect match bipartit graph runtim algorithm min height intuit improv runtim algorithm perform recurs call correspond edg random order detect perfect match rule exist perfect match difficult random version algorithm perform recurs call expect call expect save constant number recurs call impli algorithm run expect time faster determinist algorithm prove save recurs call expect variant random algorithm lemma bipartit graph vertic left vertic suppos queri access adjac matrix random queri algorithm decid perfect match make queri expect probabl make error claim prove lemma claim assum perfect match algorithm find perfect match make expect queri queri edg random order find perfect match proof perfect match call edg mark mark edg queri unmark edg probabl unmark edg queri expect number unqueri unmark edg claim assum perfect match algorithm queri expect determin perfect match probabl swap random permut vertic queri edg adjac rule exist perfect match set process vertic subset neighbourhood smaller size proof consid set prior run algorithm theorem set set assum iter remov vertex condit satisfi consid case defin construct result step algorithm probabl set set odd argument probabl set set condit set algorithm stop queri vertic perfect match rule theorem probabl process vertex process vertic expect number unprocess vertic algorithm stop probabl queri edg number queri edg inequ proof lemma prove lemma claim probabl algorithm claim probabl algorithm claim consid case perfect match expect number edg queri upper bound hand case perfect match expect number edg queri upper bound queri edg expect theorem random algorithm solv subtre isomorph root tree size constant degre height expect time algorithm subquadrat tree height log log logd constant proof random recurs algorithm decid isomorph subtre subtre subtre bipartit graph vertic left vertic connect isomorph subtre decid graph perfect match run algorithm lemma decid edg recurs proof lemma suffic queri edg level height tree upper bound desir run time acknowledg shiri chechik piotr indyk haim kaplan michael kapralov huacheng uri zwick help discuss refer abboud backur vassilevska william tight hard lcs sequenc similar measur proc foc abboud grandoni william subcub equival graph central problem apsp diamet proc soda abboud vassilevska william popular conjectur impli strong lower bound dynam problem proc foc abboud william wang approxim fix paramet subquadrat algorithm radius diamet proc soda appear abboud william weimann consequ faster align sequenc automata languag program springer akutsu halldo rsson approxim largest common subtre largest common point set theoret comput scienc akutsu tamura melkman takasu complex find largest common subtre bound degre theoret comput scienc ambaini child reichardt spalek zhang formula size evalu time quantum comput siam comput backur indyk edit distanc comput subquadrat time seth fals proc stoc bill survey tree edit distanc problem theoret comput scienc bringmann walk dog take time fre chet distanc subquadrat algorithm seth fail proc foc bringmann kunnemann quadrat condit lower bound string problem dynam time warp proc foc cheriyan random algorithm problem match theori siam journal comput chung time algorithm subgraph homeomorph problem tree journal algorithm cole hariharan tree pattern match subset match random time proc stoc cole hariharan verifi candid match spars wildcard match proc stoc cole hariharan tree pattern match subset match linear time siam journal comput cygan pachocki socala hard subgraph isomorph corr dessmark linga proskurowski faster algorithm subgraph isomorph connect partial tree algorithmica dinitz itai rodeh algorithm zemlyachenko subtre isomorph process letter dubin galil magen faster tree pattern match journal acm jacm gall power tensor fast matrix multipl proc issac gallagh match structur semant survey graph base pattern match aaai garey johnson comput intract volum freeman giannopoulou mertzio niedermei polynomi fix paramet gorithm case studi longest path interv graph proc ipec appear gibbon karp miller sorok subtre isomorph random discret appli mathemat gusfield algorithm string tree sequenc comput scienc comput biolog cambridg univers press hoffmann pattern match tree journal acm jacm hopcroft tarjan isomorph planar graph proc complex comput comput impagliazzo paturi complex sat journal comput system scienc impagliazzo paturi zane problem exponenti complex journal comput system scienc indyk determinist superimpos code applic pattern match proc foc indyk faster algorithm string match problem match convolut bound proc foc karp reduc combinatori problem complex comput putat ibm symposia seri springer khanna motwani yao approxim algorithm largest common subtre problem technic report stanford univers kilpela inen mannila order unord tree inclus siam journal comput kosaraju effici tree pattern match preliminari version proc foc linga applic maximum bipartit match subtre isomorph proc caap linga subgraph isomorph biconnect outerplanar graph cubic time theoret comput scienc linga karpinski subtre isomorph reduc bipartit perfect match ing process letter lova plummer match theori volum american mathemat soc marx pilipczuk want parameter complex subgraph isomorph afraid proc stac thoma complex find iso morphism partial tree discret mathemat matula algorithm subtre identif siam review matula subtre isomorph algorithm aspect combinator volum annal discret mathemat elsevi mucha sankowski maximum match gaussian elimin proc foc patrascu william possibl faster sat algorithm proc soda volum reyner analysi good algorithm subtre problem siam journal comput roditti vassilevska william fast approxim algorithm diamet radius spars graph proc stoc sak wigderson probabilist boolean decis tree complex evalu ate game tree proc foc shamir tsur faster subtre isomorph journal algorithm tai tree tree correct problem journal acm jacm valient algorithm tree graph springer scienc busi media verma string tree pattern process letter william algorithm optim constraint satisfact implic oret comput scienc william multipli matric faster coppersmith winograd proc stoc zhang jiang max snp hard concern unord label tree format process letter zhang shasha simpl fast algorithm edit distanc tree problem siam journal comput zhang statman shasha edit distanc unord label tree process letter analysi edmond matula algorithm variant lemma binari tree edmond matula algorithm take time proof denot size left subtre notic runtim algorithm describ recurr induct prove mention algorithm easili extend solv label version problem largest common subtre problem constant bound degre complet includ pseudo code variant solv label largest common subtre problem general algorithm llcs size size return label label llcs subtre subtre weight maximum weight bipartit match bipartit graph edg defin return lemma algorithm solv label largest common subtre problem time root tree bound degre size proof correct straightforward clear algorithm constant number oper exclud recurs call denot size maxim subtre root children root size root children root hold runtim algorithm describ recurr induct prove 