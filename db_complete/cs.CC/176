recogn union find tree complet kitti szabolc iva aunivers szege hungari abstract disjoint set forest consist union find tree data structur widespread practic applic effi cienci despit well exact structur character tree character exist union tree construct path compress paper provid character decis problem tree union find tree complet introduct disjoint set forest introduc fundament data structur practic algorithm main tain partit set support three oper cre ate partit consist singleton queri element class partit equiv alent find repres class element merg class practic exampl includ build minimum cost span tree weight graph unif algorithm support oper link list represent suffic achiev constant amort time cost oper disjoint set forest practic data structur set repres direct tree edg direct root creat oper cre ate tree node stand num ber element univers find oper take node return root tree node class oper implement find find merg oper impl ment merg tree make root node child root node node class order achiev constant effici averag height tree small orthogon method merg oper advi attach smaller tree larger size tree number node tree built union size strategi depth tree talk union rank strategi ond find oper invok node tree appli path compress method reattach ancestor direct root tree appli path compress method union size union rank strategi sequenc oper univers element support nkfi grant number worst case time cost invers extrem fast grow primit recurs ackermann function practic amort constant time cost proven data structur worst case time cost disjoint set forest equip strategi path compress offer theoret optim data structur perform except well prac tice theori detail standard textbook data structur fact interest theo retic well practic point view character tree forest singleton number merg find oper call union find tree paper test disjoint set implement point execut tree disjoint set forest valid union find tree bug implement data structur neverth character union tree till correspond case union strategi path compress case data structur offer theoret bound log amort time cost practic implementa tion imbu path compress well character cover case well paper recognit problem union find tree complet union size strategi leav open case union rank strat egi coupl path compress confirm statement problem harder rec ogniz union tree turn low degre polynomi time notat tree tupl roott parentt finit set node roott root parentt roott map nonroot node parent graph preprint submit elsevi octob parentt direct acycl graph dag edg direct root tree node children stand set parentt children children stand shorthand children roott set depth node denot ancestor parentkt size stand number descend includ size stand size roott number node tree stand subtre parentt root oper tree merg collap ing tree roott parentt root parent disjoint merg merg order tree roott parent parent parentt parent root roott parent parent nonroot node tree root parent node collaps tree root parent parent root root ancestor parent parent exampl figur class union tree class tree satisfi condit singleton tree exact node union tree union tree size size merg union tree well analog class union find tree class tree satisfi three condit singleton tree union find tree union find tree size size merg union find tree well union find tree node collaps union find tree frequent sum size small children node introduc shorthand tree node threshold sumsiz stand children size size node tree satisfi union condit child sumsiz size violat union condit child character union tree formul term theorem tree union tree node satisfi union condit equival satisisfi union condit enumer children size size size size leaf node leaf child structur character union find tree suppos tree set node root write impli clear partial order set tree reflex transit antisymmetr relat clear parent hold equival requir parent parentt parent notion defin partial oper push tree tree sibl parent push defin tree roott parent parent parentt push node level deeper tree sibl figur write push usual denot reflex transit closur serv push size size size size size size partial order tree mere coincid proposit pair tree proof impli suffic impli preorder parent sibl common parent push parent parentt parentt parentt parent parent parentt node clear equal singleton tree impli tree size appli induct size parent parent well stand set children depth node stand children clear node depth satisfi parent parent parent node depth well node exist uniqu node stand defin tree push children children appli induct hypothesi subtre transform subtre repeat appli push oper well relat introduc intim rela tion union find union tree theorem tree union find tree union tree proof union find tree claim struc tural induct singleton tree claim hold singleton tree union tree well suppos merg induct hypothesi union tree tree merg final assum collaps node roott ancestr sequenc defin push union tree appli ing induct hypothesi hold assum equival union tree claim induct size singleton tree claim hold singleton tree union find tree parent tree parent union tree assum claim hold tree node stand set children depth node stand children defin tree parenti parenti parentt induct hypothesi tree union find tree union tree root satisfi union condit member children order size size tree singleton tree merg tyi valid union find tree well union find tree union condit respect size size size final tree tree construct appli success collaps oper node union find tree well complex recognit union find tree complet note membership clear theo rem number push bound paramet call heavi threshold paramet root parent tree call node light size heavi size basket heavi child note basket heavi type basket empti basket node singl child node size call tree flat satisfi condit depth node empti basket exact basket heavi depth node size total size light depth node light node basket heavi node union tree direct children descend figur fact push oper decreas size node corollari proposit heavi basket resp node heavi basket resp node well cons quentli light light well proof retain heavi simpli size size basket node heavi child well uniqu child ancestor size size size heavi basket well will frequent sum size light children node tree node sumlight stand sumsiz total size light children introduc charg function tree node charg denot light node sumlight worth observ basket heavi node sumlight size basket child light note charg node comput multiset size children multiset size light children size push parentt common parent node node multiset chang list vari depend light heavi node note size size charg differ heavi sumlight sumlight size size size light node size size remain light push sumlight sumlight light light node size size heavi push heavi well size size sumlight sumlight size size size size size size heavi light children assumpt light child light light iii heavi light push heavi well heavi sumlight sumlight size child lose status light size heavi node light children total size size size light light heavi heavi well lose light child gain light child size size final heavi heavi well lose gain light child observ case case iii hold total charg decreas case flat tree easi check sumlight assumpt root node heavi empti basket light node charg final heavi node size charg well light node make total sum charg charg function introduc turn fact proposit union tree node proof light node heavi node basket chil dren light node sumlight size mak ing size nonneg size heavi final basket node heavi child smallest heavi child union tree sumsiz size size choic child lighter light sumsiz size sumsiz sumlight size heavi sumlight yield sumlight statement prove flat tree total charg union tree node nonneg charg push oper ther decreas total charg case iii leav total charg unchang case lemma suppos flat tree union tree sequenc push oper transform push oper type light node push light node yield light node node heavi light push heavi node charg node heavi node charg tree iff sumlight yield basket heavi node size exact worth observ ing appli three oper creat heavi node light node remain light time basket node sumlight union tree exist heavi child size act basket node exist heavi child size lightest heavi child union condit violat recal flat tree empti basket basket total depth empti basket root node basket heavi node basket initi size node light union tree set basket heavi node coincid size node increas size node push node sum result reason lemma suppos flat tree union tree push sequenc transform push form push light node light node result remain light push node basket restrict order oper appli assum push light node size size push basket push basket push simpli swap push oper light node basket descend readi sibl well push sibl tree push flat tree union tree assum push node basket light node light node yield light node turn type push union status tree consid proposit suppos tree basket node violat ing union condit child hold sumsiz size size tree push light node total size violat union condit proof children children children light basket child size union condit violat assum children push lose child size size child size size gain child size size size clear sumsiz sumsiz equal hold size size min size size strict inequ hold case clear child size size suffic fine child size minimum sumsiz sumsiz size sumsiz size size size violat union condit well observ initi flat tree basket node violat union condit push arbitrari node basket basket union status chang push basket status parent chang basket push node basket union tree case transform tree union tree push light node light node arriv character proposit assum flat tree empti basket union find tree set depth light node partit set size size size size size proof assum set depth light node partit set empti basket node push member basket leav member depth arriv tree basket node satisfi union condit light children violat condit assumpt heavi child size violat condit sumlight size sumption final root node children ini tialli empti basket size light children total size heavi child size size sum ming depth basket violat union condit union tree union find tree direct assum union find tree flat tree transform union tree repeat push node basket push node origin parent basket well parent basket push set node children basket chang pro cess charg node union tree gain bas ket heavi child size exact sumlight hold stand basket node well defin set light children suffic point recal problem partit complet strong sens list posit integ integ exist partit set satisfi strong sens problem remain complet number encod unari observ condit set exact three element sum input number sum larger solut hold note instanc problem offset instanc set solu tion coincid instanc satisfi solut triplet iff solut solut direct straightforward check set offset max log case suitabl integ problem complet definit partit input sequenc posit integ posit integ form integ output exist partit set satisfi observ solut consist exact three element readi complet recognit union find tree logspac reduc tion partit problem instanc partit problem defin flat tree number empti basket heavi threshold paramet tree target sum integ light node depth member input light node size associ light node size associ note partit problem complet assum input number encod unari tree built logspac polytim figur exampl order eas notat member sequenc multiset satisfi union condit sum member sequenc addit sequenc satisfi union condit element clear node tree satisfi union condit multiset size children lemma state construct deed reduct lemma instanc partit problem solut iff union find tree proof direct assum solut instanc multiset size light node partit set clear proposit satisfi union condit element size clear smallest element consist three integ sum hand definit partit problem recal weight smaller sum weight appli satisfi union condit well member suffic left sum exceed proposit union find tree figur direct suppos union find tree proposit multiset size light node partit set sum exact satisfi union condit exact small weight note exceed weight prove induct smallest integ induct lightest member size sum weight size well weight smallest integ violat union condit set jki smallest element number set number small weight size set exact small weight size small weight sum exact set weight sum exact set yield solut instanc partit problem conclud proof complet partit problem reduc problem flat tree union find tree flat tree union find tree con struct union tree appli finit path pression move light node basket call find oper success proven theorem complet flat tree decid flat tree union find tree flat tree construct union tree appli number path compress oper conclus futur direct effici gorithm check tree valid union find tree assum union size strategi usag path pression problem complet natur que tion recognit problem remain hard assum ing union rank strategi cours path compress height merg tree add creas obvious encod arithmet construct tree character push oper unclear hold case set path compress alter order subsequ merg refer refer leizhen cai recognit union tree inf process lett thoma cormen clifford stein ronald rivest charl lei erson introduct algorithm mcgraw hill higher educ edit fredman sak cell probe complex dynam data structur proceed twenti annual acm symposium theori comput stoc york usa acm bernard galler michael fisher improv equival algo rithm commun acm michael garey david johnson comput intract guid theori complet freeman york usa kevin knight unif multidisciplinari survey acm comput surv march robert endr tarjan effici good linear set union algo rithm acm april tree root merg push collaps figur merg collaps push figur flat tree depth light node size sum figur illustr reduct small weight size figur union tree correspond solut instanc figur 